// VLESS proxy server — Phase 1 (plaintext)
// Protocol: https://xtls.github.io/development/protocols/vless.html
//
// VLESS Request:
//   [1B version][16B UUID][1B addons_len][addons...]
//   [1B command][2B port BE][1B addr_type][addr...][payload...]
//
// VLESS Response:
//   [1B version=0][1B addons_len=0][payload...]
//
// Address types: 1=IPv4(4B), 2=domain(1B len + string), 3=IPv6(16B)
// Commands: 1=TCP, 2=UDP (only TCP supported in Phase 1)

import std::bytes
import std::net
import std::uuid
import std::thread
import std::os

// ── Constants ────────────────────────────────────────────────

comptime int VLESS_VERSION = 0
comptime int CMD_TCP = 1
comptime int CMD_UDP = 2
comptime int ADDR_IPV4 = 1
comptime int ADDR_DOMAIN = 2
comptime int ADDR_IPV6 = 3

// ── Parsed VLESS request ────────────────────────────────────

struct VlessRequest:
    int command
    string address
    int port
    int payload_offset
    bytes client_uuid

    constructor():
        this.command = 0
        this.address = ""
        this.port = 0
        this.payload_offset = 0
        this.client_uuid = bytes::create(0)

// ── Parse VLESS request ─────────────────────────────────────

VlessRequest fn parse_request(bytes data):
    // Minimum: 1(ver) + 16(uuid) + 1(addons_len) + 1(cmd) + 2(port) + 1(addr_type) + 1(addr) = 23
    if data.len() < 23:
        throw "VLESS: request too short"

    VlessRequest req = VlessRequest()
    int offset = 0

    // Version
    int version = data.get(offset)
    offset = offset + 1

    // UUID (16 bytes)
    req.client_uuid = data.slice(offset, offset + 16)
    offset = offset + 16

    // Addons
    int addons_len = data.get(offset)
    offset = offset + 1
    offset = offset + addons_len

    // Command
    req.command = data.get(offset)
    offset = offset + 1

    // Port (big-endian u16)
    req.port = data.read_u16_be(offset)
    offset = offset + 2

    // Address type
    int addr_type = data.get(offset)
    offset = offset + 1

    if addr_type == ADDR_IPV4:
        // 4 bytes → "a.b.c.d"
        int a = data.get(offset)
        int b = data.get(offset + 1)
        int c = data.get(offset + 2)
        int d = data.get(offset + 3)
        req.address = "${a}.${b}.${c}.${d}"
        offset = offset + 4
    elif addr_type == ADDR_DOMAIN:
        int domain_len = data.get(offset)
        offset = offset + 1
        bytes domain_bytes = data.slice(offset, offset + domain_len)
        req.address = domain_bytes.to_string()
        offset = offset + domain_len
    elif addr_type == ADDR_IPV6:
        bytes ipv6 = data.slice(offset, offset + 16)
        req.address = ipv6.to_hex()
        offset = offset + 16
    else:
        throw "VLESS: unknown address type ${addr_type}"

    req.payload_offset = offset
    return req

// ── Build VLESS response ────────────────────────────────────

bytes fn build_response():
    // Response header: [version=0][addons_len=0]
    bytes resp = bytes::create(2)
    resp.set(0, 0)
    resp.set(1, 0)
    return resp

// ── TCP relay ───────────────────────────────────────────────

void fn relay(int from_fd, int to_fd):
    // Forward data from one fd to another until connection closes
    while true:
        bytes chunk = net::tcp_recv_bytes(from_fd, 8192)
        if chunk.len() == 0:
            break
        net::tcp_send_bytes(to_fd, chunk)

// ── Handle one VLESS connection ─────────────────────────────

void fn handle_client(int client_fd, bytes auth_uuid):
    // Read initial data (VLESS header + first payload chunk)
    bytes data = net::tcp_recv_bytes(client_fd, 65536)
    if data.len() == 0:
        net::tcp_close(client_fd)
        return

    // Parse VLESS request
    VlessRequest req = VlessRequest()
    try:
        req = parse_request(data)
    catch:
        println("VLESS: failed to parse request")
        net::tcp_close(client_fd)
        return

    // Authenticate UUID
    if uuid::equals(req.client_uuid, auth_uuid) == false:
        println("VLESS: auth failed — invalid UUID")
        net::tcp_close(client_fd)
        return

    // Only TCP supported
    if req.command != CMD_TCP:
        println("VLESS: unsupported command ${req.command}")
        net::tcp_close(client_fd)
        return

    string dest_host = req.address
    int dest_port = req.port

    println("[VLESS] ${dest_host}:${dest_port}")

    // Connect to destination
    int remote_fd = 0
    try:
        remote_fd = net::tcp_connect(dest_host, dest_port)
    catch:
        println("VLESS: failed to connect to ${dest_host}:${dest_port}")
        net::tcp_close(client_fd)
        return

    // Send VLESS response header
    bytes resp_header = build_response()
    net::tcp_send_bytes(client_fd, resp_header)

    // Send initial payload (data after VLESS header) to remote
    if req.payload_offset < data.len():
        bytes initial_payload = data.slice(req.payload_offset, data.len())
        net::tcp_send_bytes(remote_fd, initial_payload)

    // Bidirectional relay using two threads
    // Thread 1: remote → client
    thread::Thread t = thread::spawn(():
        try:
            relay(remote_fd, client_fd)
        catch:
            pass
    )

    // Main: client → remote
    try:
        relay(client_fd, remote_fd)
    catch:
        pass

    // Cleanup
    t.wait()
    net::tcp_close(remote_fd)
    net::tcp_close(client_fd)

// ── Main ────────────────────────────────────────────────────

void fn main():
    vector[string] args = os::args()

    // Default config
    string listen_host = "0.0.0.0"
    int listen_port = 1080
    string uuid_str = ""

    // Parse args: vless <uuid> [host:port]
    if args.len() < 2:
        println("Usage: vless <uuid> [listen_host] [listen_port]")
        println("Example: vless 550e8400-e29b-41d4-a716-446655440000")
        println("         vless 550e8400-e29b-41d4-a716-446655440000 0.0.0.0 443")
        os::exit(1)

    uuid_str = args.at(1)

    if args.len() >= 3:
        listen_host = args.at(2)
    if args.len() >= 4:
        listen_port = __str_to_int(args.at(3))

    // Parse auth UUID
    bytes auth_uuid = uuid::parse(uuid_str)
    println("VLESS server starting on ${listen_host}:${listen_port}")
    println("Auth UUID: ${uuid_str}")

    // Listen
    int server_fd = net::tcp_listen(listen_host, listen_port)

    // Accept loop
    while true:
        int client_fd = net::tcp_accept(server_fd)
        // Handle each connection in a new thread
        thread::Thread t = thread::spawn(():
            handle_client(client_fd, auth_uuid)
        )
        t.detach()
