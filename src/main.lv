import codegen
import checker
import parser

// ═══════════════════════════════════════════════════════════════
//  Lavina Bootstrap Compiler — Main CLI
//  Resolves imports, compiles .lv → C++ → binary → run
// ═══════════════════════════════════════════════════════════════

// ── Import Resolver ──────────────────────────────────────────

class ImportResolver:
    vector[string] resolved_paths

    constructor():
        this.resolved_paths = []

    bool fn already_resolved(ref string path):
        for p in this.resolved_paths:
            if p == path:
                return true
        return false

    string fn get_directory(ref string path):
        int i = path.len() - 1
        while i >= 0:
            if path.charAt(i) == "/":
                return path.substring(0, i + 1)
            i -= 1
        return "./"

    string fn resolve(string file_path):
        if this.already_resolved(file_path):
            return ""
        this.resolved_paths.push(file_path)

        string source = fs_read(file_path)
        string dir = this.get_directory(file_path)

        string result = ""
        vector[string] lines = source.split("\n")
        for line in lines:
            string trimmed = line.trim()
            if trimmed.starts_with("import "):
                string module_name = trimmed.substring(7, trimmed.len()).trim()
                string module_path = dir + module_name + ".lv"
                string resolved = this.resolve(module_path)
                if resolved != "":
                    result = result + resolved + "\n"
            else:
                result = result + line + "\n"
        return result

// ── Main entry point ─────────────────────────────────────────

int fn main():
    auto args = os_args()
    if args.len() < 2:
        print("Usage: bootstrap [--emit-cpp | compile] <file.lv>")
        return 1

    string mode = "run"
    string path = ""
    bool no_check = false

    // Parse arguments
    int ai = 1
    while ai < args.len():
        if args[ai] == "--no-check":
            no_check = true
        elif args[ai] == "--emit-cpp":
            mode = "emit-cpp"
        elif args[ai] == "compile":
            mode = "compile"
        else:
            path = args[ai]
        ai += 1

    if path == "":
        print("Usage: bootstrap [--emit-cpp | compile] [--no-check] <file.lv>")
        return 1

    auto resolver = ImportResolver()
    string source = resolver.resolve(path)

    auto scanner = Scanner(source)
    scanner.scan_tokens()
    if scanner.errors.len() > 0:
        print("Scanner errors:")
        for err in scanner.errors:
            print(err)
        return 1

    vector[Stmt] stmts = []
    string cpp = ""
    bool has_main = false
    try:
        auto parser = Parser(scanner.tokens)
        stmts = parser.parse_program()

        if not no_check:
            auto check_errors = run_checker(stmts)
            if check_errors.len() > 0:
                print("Type check errors:")
                for cerr in check_errors:
                    print("  " + cerr)
                return 1

        auto codegen = CppCodegen()
        cpp = codegen.generate(stmts)
        has_main = codegen.has_main
    catch err:
        print("Error: " + err.what())
        return 1

    if mode == "emit-cpp":
        print(cpp)
        return 0

    if not has_main:
        print("Error: no main() function defined.")
        return 1

    string dir = resolver.get_directory(path)
    string base = path
    int si = path.len() - 1
    while si >= 0:
        if path.charAt(si) == "/":
            base = path.substring(si + 1, path.len())
            break
        si -= 1
    if base.ends_with(".lv"):
        base = base.substring(0, base.len() - 3)

    string cpp_path = dir + base + ".cpp"
    string bin_path = dir + base
    string header_path = dir + "lavina.h"

    fs_write(cpp_path, cpp)

    bool wrote_header = false
    string liblavina_path = dir + "liblavina"
    if not fs_exists(header_path):
        try:
            string header_content = fs_read("runtime/lavina.h")
            fs_write(header_path, header_content)
            os_exec("cp -r runtime/liblavina " + liblavina_path)
            wrote_header = true
        catch:
            print("Warning: could not find runtime/lavina.h")

    string compile_cmd = "g++ -std=c++23 -o " + bin_path + " " + cpp_path
    int compile_result = os_exec(compile_cmd)
    if compile_result != 0:
        print("Compilation failed")
        os_exec("rm -f " + cpp_path)
        if wrote_header:
            os_exec("rm -f " + header_path)
            os_exec("rm -rf " + liblavina_path)
        return 1

    if mode == "compile":
        os_exec("rm -f " + cpp_path)
        if wrote_header:
            os_exec("rm -f " + header_path)
            os_exec("rm -rf " + liblavina_path)
        print("Compiled: " + bin_path)
        return 0

    int run_result = os_exec(bin_path)

    os_exec("rm -f " + cpp_path)
    os_exec("rm -f " + bin_path)
    if wrote_header:
        os_exec("rm -f " + header_path)
        os_exec("rm -rf " + liblavina_path)

    if run_result != 0:
        return 1
    return 0
