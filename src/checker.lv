import ast

// ═══════════════════════════════════════════════════════════════
//  Lavina Bootstrap Compiler — Type Checker
//  Walks the AST between parsing and codegen to catch errors.
// ═══════════════════════════════════════════════════════════════

// ── Symbol & Scope ─────────────────────────────────────────────

struct Symbol:
    string name
    TypeNode sym_type
    string kind
    bool is_ref
    bool is_mutable

struct Scope:
    vector[string] names
    vector[Symbol] symbols

// ── Checker ────────────────────────────────────────────────────

class Checker:
    vector[Scope] scopes
    vector[string] errors
    vector[string] warnings
    // Registries
    hashmap[string, vector[EnumVariantNode]] known_enums
    hashmap[string, ExternFn] known_funcs
    hashmap[string, vector[Stmt]] known_classes
    // Context
    TypeNode current_return_type
    bool in_class
    string current_class_name

    constructor():
        this.scopes = []
        this.errors = []
        this.warnings = []
        this.known_enums = {}
        this.known_funcs = {}
        this.known_classes = {}
        this.current_return_type = TypeNode::None()
        this.in_class = false
        this.current_class_name = ""

    // ── Error helpers ──────────────────────────────────────────

    void fn error(ref string msg, ref Token t):
        this.errors.push("[${t.line}:${t.col}] Error: ${msg}")

    void fn error_msg(ref string msg):
        this.errors.push("Error: ${msg}")

    void fn warn(ref string msg, ref Token t):
        this.warnings.push("[${t.line}:${t.col}] Warning: ${msg}")

    // ── Scope management ───────────────────────────────────────

    void fn push_scope():
        vector[string] names = []
        vector[Symbol] syms = []
        this.scopes.push(Scope(names, syms))

    void fn pop_scope():
        this.scopes.pop()

    void fn declare(ref string name, ref TypeNode t, ref string kind, bool is_ref, bool is_mutable, ref Token tok):
        if this.scopes.len() == 0:
            return
        ref! auto scope = this.scopes[this.scopes.len() - 1]
        // Check for redefinition in current scope
        for ref n in scope.names:
            if n == name:
                this.warn("Redefinition of '${name}' in same scope", tok)
                return
        scope.names.push(name)
        scope.symbols.push(Symbol(name, t, kind, is_ref, is_mutable))

    bool fn resolve(ref string name):
        int i = this.scopes.len() - 1
        while i >= 0:
            ref! auto scope = this.scopes[i]
            for ref n in scope.names:
                if n == name:
                    return true
            i -= 1
        // Check top-level: functions, classes, enums
        if this.known_funcs.has(name):
            return true
        if this.known_classes.has(name):
            return true
        if this.known_enums.has(name):
            return true
        // Check if this is a generic instantiation like "Pair<int64_t, std::string>"
        int angle = name.indexOf("<")
        if angle >= 0:
            string base = name.substring(0, angle)
            return this.resolve(base)
        return false

    Symbol fn lookup(ref string name):
        int i = this.scopes.len() - 1
        while i >= 0:
            ref! auto scope = this.scopes[i]
            for j in 0..scope.names.len():
                if scope.names[j] == name:
                    return scope.symbols[j]
            i -= 1
        return Symbol(name, TypeNode::Auto(), "unknown", false, false)

    // ── Type compatibility ─────────────────────────────────────

    bool fn types_compatible(ref TypeNode expected, ref TypeNode actual):
        // Empty literal [] (Array(Auto)) is compatible with any container
        match actual:
            Array(a_inner):
                match a_inner:
                    Auto():
                        match expected:
                            Array(e_inner):
                                return true
                            HashSet(e_inner):
                                return true
                            HashMap(ek, ev):
                                return true
                            _:
                                pass
                    _:
                        pass
            _:
                pass
        // Array type compatibility
        match expected:
            Array(e_inner):
                match actual:
                    Array(a_inner):
                        return this.types_compatible(e_inner, a_inner)
                    _:
                        pass
            _:
                pass
        // Auto/None/Dynamic accept anything
        match expected:
            Auto():
                return true
            None():
                return true
            Dynamic():
                return true
            _:
                pass
        match actual:
            Auto():
                return true
            None():
                return true
            Dynamic():
                return true
            _:
                pass
        // Same type check
        string e = this.type_name(expected)
        string a = this.type_name(actual)
        if e == a:
            return true
        // Integer family compatibility
        bool e_is_int = false
        bool a_is_int = false
        match expected:
            Int():
                e_is_int = true
            Int8():
                e_is_int = true
            Int16():
                e_is_int = true
            Int32():
                e_is_int = true
            USize():
                e_is_int = true
            _:
                pass
        match actual:
            Int():
                a_is_int = true
            Int8():
                a_is_int = true
            Int16():
                a_is_int = true
            Int32():
                a_is_int = true
            USize():
                a_is_int = true
            _:
                pass
        if e_is_int and a_is_int:
            return true
        // Float family compatibility
        bool e_is_float = false
        bool a_is_float = false
        match expected:
            Float():
                e_is_float = true
            Float32():
                e_is_float = true
            _:
                pass
        match actual:
            Float():
                a_is_float = true
            Float32():
                a_is_float = true
            _:
                pass
        if e_is_float and a_is_float:
            return true
        // Float accepts Int
        if e_is_float and a_is_int:
            return true
        // CString compatible with Str
        match expected:
            CString():
                match actual:
                    Str():
                        return true
                    _:
                        pass
            Str():
                match actual:
                    CString():
                        return true
                    _:
                        pass
            _:
                pass
        // Nullable(T) accepts T or NullType
        match expected:
            Nullable(inner):
                match actual:
                    NullType():
                        return true
                    _:
                        return this.types_compatible(inner, actual)
            _:
                pass
        // Ptr(T) accepts NullType
        match expected:
            Ptr(inner):
                match actual:
                    NullType():
                        return true
                    _:
                        pass
            _:
                pass
        return false

    string fn type_name(ref TypeNode t):
        match t:
            Int():
                return "int"
            Float():
                return "float"
            Str():
                return "string"
            Bool():
                return "bool"
            Void():
                return "void"
            Auto():
                return "auto"
            Dynamic():
                return "dynamic"
            NullType():
                return "null"
            Custom(name, _):
                return name
            Array(inner):
                return "vector[${this.type_name(inner)}]"
            HashSet(inner):
                return "set[${this.type_name(inner)}]"
            HashMap(k, v):
                return "map[${this.type_name(k)}, ${this.type_name(v)}]"
            Nullable(inner):
                return "${this.type_name(inner)}?"
            Int8():
                return "int8"
            Int16():
                return "int16"
            Int32():
                return "int32"
            Float32():
                return "float32"
            USize():
                return "usize"
            CString():
                return "cstring"
            Ptr(inner):
                return "ptr[${this.type_name(inner)}]"
            _:
                return "unknown"

    // ── Type inference ─────────────────────────────────────────

    TypeNode fn infer_type(ref Expr e):
        match e:
            None():
                return TypeNode::None()
            Literal(kind, value):
                if kind == "int":
                    return TypeNode::Int()
                elif kind == "float":
                    return TypeNode::Float()
                elif kind == "string":
                    return TypeNode::Str()
                elif kind == "bool":
                    return TypeNode::Bool()
                elif kind == "null":
                    return TypeNode::NullType()
                return TypeNode::Auto()
            Variable(name):
                auto sym = this.lookup(name.lexeme)
                return sym.sym_type
            Binary(left, op, right):
                auto lt = this.infer_type(left)
                auto rt = this.infer_type(right)
                // Comparison ops return bool
                if op.token_type == TK_EQUAL_EQUAL or op.token_type == TK_BANG_EQUAL or op.token_type == TK_LESS or op.token_type == TK_LESS_EQUAL or op.token_type == TK_GREATER or op.token_type == TK_GREATER_EQUAL:
                    return TypeNode::Bool()
                // String + anything = string
                match lt:
                    Str():
                        return TypeNode::Str()
                    _:
                        pass
                // Arithmetic: if either is float, result is float
                match lt:
                    Float():
                        return TypeNode::Float()
                    _:
                        pass
                match rt:
                    Float():
                        return TypeNode::Float()
                    _:
                        pass
                match lt:
                    Int():
                        return TypeNode::Int()
                    _:
                        pass
                return TypeNode::Auto()
            Unary(op, right):
                if op.token_type == TK_BANG or op.token_type == TK_NOT:
                    return TypeNode::Bool()
                return this.infer_type(right)
            Logical(left, op, right):
                return TypeNode::Bool()
            Call(callee, paren, args):
                return this.infer_call_type(callee)
            Grouping(inner):
                return this.infer_type(inner)
            Index(object, bracket, index):
                auto ot = this.infer_type(object)
                match ot:
                    Array(inner):
                        return inner
                    _:
                        return TypeNode::Auto()
            Vector(elements):
                if elements.len() > 0:
                    auto inner = this.infer_type(elements[0])
                    return TypeNode::Array(inner)
                return TypeNode::Array(TypeNode::Auto())
            Cast(expr, target_type):
                return target_type
            This(kw):
                return TypeNode::Custom(this.current_class_name, [])
            Own(expr):
                return this.infer_type(expr)
            AddressOf(expr):
                return TypeNode::Ptr(this.infer_type(expr))
            _:
                return TypeNode::Auto()

    TypeNode fn infer_call_type(ref Expr callee):
        match callee:
            Variable(name):
                // Look up in function registry
                if this.known_funcs.has(name.lexeme):
                    ExternFn fi = this.known_funcs[name.lexeme]
                    return fi.return_type
                // Constructor call — returns the class type
                if this.known_classes.has(name.lexeme):
                    return TypeNode::Custom(name.lexeme, [])
                if this.known_enums.has(name.lexeme):
                    return TypeNode::Custom(name.lexeme, [])
                return TypeNode::Auto()
            Get(object, name):
                return TypeNode::Auto()
            StaticGet(object, name):
                // Enum::Variant
                match object:
                    Variable(obj_name):
                        if this.known_enums.has(obj_name.lexeme):
                            return TypeNode::Custom(obj_name.lexeme, [])
                    _:
                        pass
                return TypeNode::Auto()
            _:
                return TypeNode::Auto()

    // ── Enum helpers ───────────────────────────────────────────

    string fn find_enum_for_variant(ref string variant_name):
        vector[string] keys = this.known_enums.keys()
        for ref key in keys:
            vector[EnumVariantNode] variants = this.known_enums[key]
            for ref v in variants:
                if v.name.lexeme == variant_name:
                    return key
        return ""

    // ── Statement checking ─────────────────────────────────────

    void fn register_builtins():
        // Runtime functions that are always available
        vector[string] builtins = ["print", "println", "lv_assert", "fs_read", "fs_write", "fs_exists", "os_exec", "os_args", "to_string", "to_int", "to_float", "input", "typeof", "len", "exit", "abs"]
        vector[Param] empty_params = []
        for ref name in builtins:
            this.known_funcs[name] = ExternFn(name, name, TypeNode::Auto(), empty_params)
        pass

    void fn check(ref vector[Stmt] stmts):
        this.register_builtins()
        // Pass 1: collect top-level declarations
        this.push_scope()
        for ref s in stmts:
            this.collect_decl(s)
        // Pass 2: check everything
        for ref s in stmts:
            this.check_stmt(s)
        this.pop_scope()

    void fn collect_decl(ref Stmt s):
        match s:
            Function(name, params, return_type, body, is_inline, is_comptime, is_static, visibility, type_params):
                this.known_funcs[name.lexeme] = ExternFn(name.lexeme, name.lexeme, return_type, params)
            Class(name, body, visibility):
                this.known_classes[name.lexeme] = body
            Enum(name, variants, methods, visibility, enum_tp):
                this.known_enums[name.lexeme] = variants
            Const(name, const_type, value, visibility):
                this.declare(name.lexeme, const_type, "const", false, false, name)
            Struct(name, body, visibility, struct_tp):
                this.known_classes[name.lexeme] = body
            Namespace(name, body, visibility):
                for ref ns_stmt in body:
                    this.collect_decl(ns_stmt)
            Extern(header, link_lib, types, functions):
                for ref et in types:
                    vector[Stmt] empty_body = []
                    this.known_classes[et.lavina_name] = empty_body
                for ref ef in functions:
                    this.known_funcs[ef.name] = ef
            _:
                pass

    void fn check_stmt(ref Stmt s):
        match s:
            ExprStmt(expr):
                this.check_expr(expr)
            Let(name, var_type, initializer, visibility, is_ref, is_mut):
                this.check_expr(initializer)
                auto init_type = this.infer_type(initializer)
                // Check type compatibility if type is explicit
                match var_type:
                    Auto():
                        pass
                    None():
                        pass
                    _:
                        if not this.types_compatible(var_type, init_type):
                            this.error("Cannot assign ${this.type_name(init_type)} to ${this.type_name(var_type)}", name)
                this.declare(name.lexeme, var_type, "var", is_ref, true, name)
            Const(name, const_type, value, visibility):
                this.check_expr(value)
            Return(keyword, value):
                this.check_expr(value)
                match this.current_return_type:
                    None():
                        pass
                    Void():
                        match value:
                            None():
                                pass
                            _:
                                this.error("Cannot return a value from void function", keyword)
                    _:
                        auto val_type = this.infer_type(value)
                        if not this.types_compatible(this.current_return_type, val_type):
                            this.error("Return type mismatch: expected ${this.type_name(this.current_return_type)}, got ${this.type_name(val_type)}", keyword)
            If(condition, then_branch, else_branch):
                this.check_expr(condition)
                this.check_stmt(then_branch)
                this.check_stmt(else_branch)
            While(condition, body):
                this.check_expr(condition)
                this.check_stmt(body)
            For(item_name, collection, body, is_ref, is_mut):
                this.check_expr(collection)
                this.push_scope()
                // Infer item type from collection
                auto coll_type = this.infer_type(collection)
                auto item_type = TypeNode::Auto()
                match coll_type:
                    Array(inner):
                        item_type = inner
                    _:
                        pass
                this.declare(item_name.lexeme, item_type, "var", is_ref, is_mut or not is_ref, item_name)
                this.check_stmt(body)
                this.pop_scope()
            Block(statements):
                this.push_scope()
                for ref st in statements:
                    this.check_stmt(st)
                this.pop_scope()
            Function(name, params, return_type, body, is_inline, is_comptime, is_static, visibility, type_params):
                this.check_function(name, params, return_type, body)
            Class(name, body, visibility):
                this.check_class(name, body)
            Struct(name, body, visibility, struct_tp):
                pass
            Enum(name, variants, methods, visibility, enum_tp):
                pass
            Match(expr, arm_patterns, arm_bodies):
                this.check_expr(expr)
                this.check_match(expr, arm_patterns, arm_bodies)
            Try(try_body, catch_body, exception_name):
                this.push_scope()
                this.check_stmt(try_body)
                this.pop_scope()
                this.push_scope()
                if exception_name != "":
                    this.declare(exception_name, TypeNode::Auto(), "var", false, false, Token(TK_IDENTIFIER, exception_name, 0, 0))
                this.check_stmt(catch_body)
                this.pop_scope()
            Namespace(name, body, visibility):
                this.push_scope()
                for ref ns_stmt in body:
                    this.collect_decl(ns_stmt)
                for ref ns_stmt in body:
                    this.check_stmt(ns_stmt)
                this.pop_scope()
            Import(path, alias):
                pass
            Break(keyword):
                pass
            Continue(keyword):
                pass
            Pass(keyword):
                pass
            CppBlock(code):
                pass
            Extern(header, link_lib, types, functions):
                pass
            _:
                pass

    void fn check_function(ref Token name, ref vector[Param] params, ref TypeNode return_type, ref vector[Stmt] body):
        auto saved_return = this.current_return_type
        this.current_return_type = return_type
        this.push_scope()
        for ref p in params:
            this.declare(p.name.lexeme, p.param_type, "param", p.is_ref, true, p.name)
        for ref s in body:
            this.check_stmt(s)
        this.pop_scope()
        this.current_return_type = saved_return

    void fn check_class(ref Token name, ref vector[Stmt] body):
        bool saved_in_class = this.in_class
        string saved_class_name = this.current_class_name
        this.in_class = true
        this.current_class_name = name.lexeme
        this.push_scope()
        // Declare 'this'
        this.declare("this", TypeNode::Custom(name.lexeme, []), "var", false, false, name)
        for ref s in body:
            match s:
                Function(fname, params, return_type, fbody, is_inline, is_comptime, is_static, visibility, fn_tp):
                    this.check_function(fname, params, return_type, fbody)
                Let(lname, var_type, initializer, visibility, is_ref, is_mut):
                    this.check_expr(initializer)
                _:
                    this.check_stmt(s)
        this.pop_scope()
        this.in_class = saved_in_class
        this.current_class_name = saved_class_name

    // ── Expression checking ────────────────────────────────────

    void fn check_expr(ref Expr e):
        match e:
            None():
                pass
            Variable(name):
                if not this.resolve(name.lexeme):
                    this.error("Undefined variable '${name.lexeme}'", name)
            Binary(left, op, right):
                this.check_expr(left)
                this.check_expr(right)
            Unary(op, right):
                this.check_expr(right)
            Logical(left, op, right):
                this.check_expr(left)
                this.check_expr(right)
            Grouping(inner):
                this.check_expr(inner)
            Call(callee, paren, args):
                this.check_expr(callee)
                for ref a in args:
                    this.check_expr(a)
                this.check_call_args(callee, args, paren)
            Assign(name, value):
                this.check_expr(value)
                if not this.resolve(name.lexeme):
                    this.error("Undefined variable '${name.lexeme}'", name)
                else:
                    auto sym = this.lookup(name.lexeme)
                    if sym.kind == "const":
                        this.error("Cannot assign to constant '${name.lexeme}'", name)
            Index(object, bracket, index):
                this.check_expr(object)
                this.check_expr(index)
            IndexSet(object, bracket, index, value):
                this.check_expr(object)
                this.check_expr(index)
                this.check_expr(value)
            Vector(elements):
                for ref el in elements:
                    this.check_expr(el)
            Map(keys, values):
                for ref k in keys:
                    this.check_expr(k)
                for ref v in values:
                    this.check_expr(v)
            Get(object, name):
                this.check_expr(object)
            Set(object, name, value):
                this.check_expr(object)
                this.check_expr(value)
            StaticGet(object, name):
                // Skip checking object if it's a variable (could be a namespace)
                match object:
                    Variable(tok):
                        pass
                    _:
                        this.check_expr(object)
            Cast(expr, target_type):
                this.check_expr(expr)
            Throw(expr):
                this.check_expr(expr)
            Range(start, end):
                this.check_expr(start)
                this.check_expr(end)
            Lambda(params, body):
                this.push_scope()
                for ref p in params:
                    this.declare(p.name.lexeme, p.param_type, "param", p.is_ref, true, p.name)
                this.check_expr(body)
                this.pop_scope()
            BlockLambda(params, body_id):
                this.push_scope()
                for ref p in params:
                    this.declare(p.name.lexeme, p.param_type, "param", p.is_ref, true, p.name)
                this.pop_scope()
            Own(expr):
                this.check_expr(expr)
            AddressOf(expr):
                this.check_expr(expr)
            _:
                pass

    void fn check_call_args(ref Expr callee, ref vector[Expr] args, ref Token paren):
        match callee:
            Variable(name):
                if this.known_funcs.has(name.lexeme):
                    ExternFn fi = this.known_funcs[name.lexeme]
                    // Skip arg count check for builtins (registered with 0 params)
                    if fi.params.len() > 0 and args.len() != fi.params.len():
                        this.error("Function '${name.lexeme}' expects ${fi.params.len()} args, got ${args.len()}", paren)
                    return
            _:
                pass

    // ── Match checking ─────────────────────────────────────────

    void fn check_match(ref Expr expr, ref vector[MatchArm] arm_patterns, ref vector[Stmt] arm_bodies):
        bool has_wildcard = false
        for i in 0..arm_patterns.len():
            auto arm = arm_patterns[i]
            if arm.pattern_name == "_":
                has_wildcard = true
            else:
                // Check variant exists
                string enum_name = this.find_enum_for_variant(arm.pattern_name)
                if enum_name == "":
                    // Not a known variant — might be a binding, skip
                    pass
            this.push_scope()
            // Declare bindings
            for ref b in arm.bindings:
                this.declare(b, TypeNode::Auto(), "var", false, false, Token(TK_IDENTIFIER, b, 0, 0))
            this.check_stmt(arm_bodies[i])
            this.pop_scope()

// ── Public API ─────────────────────────────────────────────────

vector[string] fn run_checker(ref vector[Stmt] stmts):
    auto checker = Checker()
    checker.check(stmts)
    // Print warnings
    for ref w in checker.warnings:
        print(w)
    return checker.errors
