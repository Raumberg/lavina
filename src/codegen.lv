import ast

// ═══════════════════════════════════════════════════════════════
//  Lavina Bootstrap Compiler — C++ Code Generator
//  Takes AST from the parser and produces C++ source code.
// ═══════════════════════════════════════════════════════════════

class CppCodegen:
    string output
    string declarations
    int indent_level
    int temp_counter
    bool has_main
    vector[string] known_enum_names
    vector[vector[EnumVariantNode]] known_enum_variants
    vector[string] dynamic_vars

    constructor():
        this.output = ""
        this.declarations = ""
        this.indent_level = 0
        this.temp_counter = 0
        this.has_main = false
        this.known_enum_names = []
        this.known_enum_variants = []
        this.dynamic_vars = []

    // ── Helpers ───────────────────────────────────────────────

    string fn indent():
        string result = ""
        for i in 0..this.indent_level:
            result = result + "    "
        return result

    bool fn is_dynamic_var(string name):
        for v in this.dynamic_vars:
            if v == name:
                return true
        return false

    void fn add_dynamic_var(string name):
        if not this.is_dynamic_var(name):
            this.dynamic_vars.push(name)

    string fn find_enum_for_variant(string variant_name):
        string found = ""
        int count = 0
        for i in 0..this.known_enum_names.len():
            vector[EnumVariantNode] variants = this.known_enum_variants[i]
            for v in variants:
                if v.name.lexeme == variant_name:
                    if count == 0:
                        found = this.known_enum_names[i]
                    count += 1
        if count == 1:
            return found
        return ""

    bool fn variant_has_fields(string enum_name, string variant_name):
        for i in 0..this.known_enum_names.len():
            if this.known_enum_names[i] == enum_name:
                vector[EnumVariantNode] variants = this.known_enum_variants[i]
                for v in variants:
                    if v.name.lexeme == variant_name:
                        return v.types.len() > 0
                return false
        return false

    EnumVariantNode fn get_variant_info(string enum_name, string variant_name):
        for i in 0..this.known_enum_names.len():
            if this.known_enum_names[i] == enum_name:
                vector[EnumVariantNode] variants = this.known_enum_variants[i]
                for v in variants:
                    if v.name.lexeme == variant_name:
                        return v
        vector[TypeNode] empty_types = []
        vector[string] empty_names = []
        return EnumVariantNode(Token("", "", 0, 0), empty_types, empty_names)

    bool fn enum_has_data_variants(string enum_name):
        for i in 0..this.known_enum_names.len():
            if this.known_enum_names[i] == enum_name:
                vector[EnumVariantNode] variants = this.known_enum_variants[i]
                for v in variants:
                    if v.types.len() > 0:
                        return true
                return false
        return false

    bool fn is_known_enum(string name):
        for n in this.known_enum_names:
            if n == name:
                return true
        return false

    bool fn type_contains_dynamic(TypeNode t):
        match t:
            Dynamic():
                return true
            Array(inner):
                return this.type_contains_dynamic(inner)
            _:
                return false

    // ── Type emission ─────────────────────────────────────────

    string fn emit_type(TypeNode t):
        match t:
            Int():
                return "int64_t"
            Float():
                return "double"
            Str():
                return "std::string"
            Bool():
                return "bool"
            Void():
                return "void"
            Auto():
                return "auto"
            Dynamic():
                return "std::any"
            NullType():
                return "std::nullptr_t"
            Custom(name):
                return name
            Array(inner):
                return "std::vector<${this.emit_type(inner)}>"
            HashSet(inner):
                return "std::unordered_set<${this.emit_type(inner)}>"
            HashMap(key_type, value_type):
                return "std::unordered_map<${this.emit_type(key_type)}, ${this.emit_type(value_type)}>"
            Nullable(inner):
                return "std::optional<${this.emit_type(inner)}>"
            _:
                return "auto"

    string fn token_to_cpp_op(Token t):
        if t.token_type == TK_PLUS:
            return "+"
        elif t.token_type == TK_MINUS:
            return "-"
        elif t.token_type == TK_STAR:
            return "*"
        elif t.token_type == TK_SLASH:
            return "/"
        elif t.token_type == TK_PERCENT:
            return "%"
        elif t.token_type == TK_EQUAL_EQUAL:
            return "=="
        elif t.token_type == TK_BANG_EQUAL:
            return "!="
        elif t.token_type == TK_LESS:
            return "<"
        elif t.token_type == TK_LESS_EQUAL:
            return "<="
        elif t.token_type == TK_GREATER:
            return ">"
        elif t.token_type == TK_GREATER_EQUAL:
            return ">="
        elif t.token_type == TK_BANG or t.token_type == TK_NOT:
            return "!"
        elif t.token_type == TK_AND:
            return "&&"
        elif t.token_type == TK_OR:
            return "||"
        return "/* unknown op */"

    string fn default_init(string cpp_type):
        if cpp_type == "int64_t":
            return " = 0"
        elif cpp_type == "double":
            return " = 0.0"
        elif cpp_type == "bool":
            return " = false"
        elif cpp_type == "std::string":
            return " = \"\""
        return ""

    // ── Expression emission ───────────────────────────────────

    string fn emit_expr(Expr e):
        match e:
            None():
                return ""
            Literal(kind, value):
                return this.emit_literal(kind, value)
            Unary(op, right):
                string r = this.emit_expr(right)
                string op_str = this.token_to_cpp_op(op)
                return "(${op_str}${r})"
            Binary(left, op, right):
                string l = this.emit_expr(left)
                string r = this.emit_expr(right)
                string op_str = this.token_to_cpp_op(op)
                return "(${l} ${op_str} ${r})"
            Grouping(inner):
                return "(${this.emit_expr(inner)})"
            Variable(name):
                return name.lexeme
            Assign(name, value):
                return "${name.lexeme} = ${this.emit_expr(value)}"
            Logical(left, op, right):
                string l = this.emit_expr(left)
                string r = this.emit_expr(right)
                string op_str = "&&"
                if op.token_type == TK_OR:
                    op_str = "||"
                return "${l} ${op_str} ${r}"
            Call(callee, paren, args):
                return this.emit_call_expr(callee, args, false)
            Index(object, bracket, index):
                return "${this.emit_expr(object)}[${this.emit_expr(index)}]"
            IndexSet(object, bracket, index, value):
                return "${this.emit_expr(object)}[${this.emit_expr(index)}] = ${this.emit_expr(value)}"
            Vector(elements):
                if elements.len() == 0:
                    return "{}"
                vector[string] elems = []
                for el in elements:
                    elems.push(this.emit_expr(el))
                return "std::vector{${elems.join(", ")}}"
            Map(keys, values):
                vector[string] entries = []
                for i in 0..keys.len():
                    entries.push("{${this.emit_expr(keys[i])}, ${this.emit_expr(values[i])}}")
                return "{{${entries.join(", ")}}}"
            Get(object, name):
                return "${this.emit_expr(object)}.${name.lexeme}"
            Set(object, name, value):
                return "${this.emit_expr(object)}.${name.lexeme} = ${this.emit_expr(value)}"
            StaticGet(object, name):
                return "${this.emit_expr(object)}::${name.lexeme}"
            This(keyword):
                return "(*this)"
            Cast(expr, target_type):
                string ex = this.emit_expr(expr)
                string t = this.emit_type(target_type)
                if this.is_dynamic_expression(expr):
                    return "std::any_cast<${t}>(${ex})"
                return "static_cast<${t}>(${ex})"
            Throw(expr):
                return "throw std::runtime_error(${this.emit_expr(expr)})"
            _:
                return ""

    string fn emit_literal(string kind, string value):
        if kind == "int":
            return "${value}LL"
        elif kind == "float":
            return value
        elif kind == "string":
            return "std::string(\"${value}\")"
        elif kind == "bool":
            return value
        elif kind == "null":
            return "std::nullopt"
        return value

    bool fn is_dynamic_expression(Expr e):
        match e:
            Variable(name):
                return this.is_dynamic_var(name.lexeme)
            Index(object, bracket, index):
                return this.is_dynamic_expression(object)
            _:
                return false

    string fn emit_call_expr(Expr callee, vector[Expr] args, bool in_method):
        match callee:
            Get(object, name):
                string obj = ""
                if in_method:
                    obj = this.emit_method_expr(object)
                else:
                    obj = this.emit_expr(object)
                vector[string] arg_strs = []
                for a in args:
                    if in_method:
                        arg_strs.push(this.emit_method_expr(a))
                    else:
                        arg_strs.push(this.emit_expr(a))
                string remapped = this.try_remap_method(obj, name.lexeme, arg_strs)
                if remapped != "":
                    return remapped
                return "${obj}.${name.lexeme}(${arg_strs.join(", ")})"
            StaticGet(object, name):
                string obj = ""
                if in_method:
                    obj = this.emit_method_expr(object)
                else:
                    obj = this.emit_expr(object)
                vector[string] arg_strs = []
                for a in args:
                    if in_method:
                        arg_strs.push(this.emit_method_expr(a))
                    else:
                        arg_strs.push(this.emit_expr(a))
                match object:
                    Variable(tok):
                        if this.is_known_enum(tok.lexeme):
                            return "${obj}::make_${name.lexeme}(${arg_strs.join(", ")})"
                    _:
                        int noop = 0
                return "${obj}::${name.lexeme}(${arg_strs.join(", ")})"
            Variable(tok):
                vector[string] arg_strs = []
                for a in args:
                    if in_method:
                        arg_strs.push(this.emit_method_expr(a))
                    else:
                        arg_strs.push(this.emit_expr(a))
                if tok.lexeme == "exit":
                    return "lv_exit(${arg_strs.join(", ")})"
                return "${tok.lexeme}(${arg_strs.join(", ")})"
            _:
                string func = ""
                if in_method:
                    func = this.emit_method_expr(callee)
                else:
                    func = this.emit_expr(callee)
                vector[string] arg_strs = []
                for a in args:
                    if in_method:
                        arg_strs.push(this.emit_method_expr(a))
                    else:
                        arg_strs.push(this.emit_expr(a))
                return "${func}(${arg_strs.join(", ")})"

    string fn try_remap_method(string obj, string method, vector[string] args):
        if method == "len":
            return "static_cast<int64_t>(${obj}.size())"
        elif method == "is_empty":
            return "${obj}.empty()"
        elif method == "contains":
            return "lv_contains(${obj}, ${args.join(", ")})"
        elif method == "add":
            return "${obj}.insert(${args.join(", ")})"
        elif method == "upper":
            return "lv_upper(${obj})"
        elif method == "lower":
            return "lv_lower(${obj})"
        elif method == "trim":
            return "lv_trim(${obj})"
        elif method == "replace":
            return "lv_replace(${obj}, ${args.join(", ")})"
        elif method == "split":
            if args.len() > 0:
                return "lv_split(${obj}, ${args[0]})"
            return "lv_split(${obj}, std::string(\" \"))"
        elif method == "starts_with":
            return "${obj}.starts_with(${args.join(", ")})"
        elif method == "ends_with":
            return "${obj}.ends_with(${args.join(", ")})"
        elif method == "indexOf":
            return "lv_index_of(${obj}, ${args.join(", ")})"
        elif method == "charAt":
            return "std::string(1, ${obj}[${args.join(", ")}])"
        elif method == "substring":
            if args.len() >= 2:
                return "${obj}.substr(${args[0]}, (${args[1]}) - (${args[0]}))"
            return "${obj}.substr(${args.join(", ")})"
        elif method == "push":
            return "${obj}.push_back(${args.join(", ")})"
        elif method == "pop":
            return "lv_pop(${obj})"
        elif method == "clear":
            return "${obj}.clear()"
        elif method == "remove":
            return "lv_remove(${obj}, ${args.join(", ")})"
        elif method == "join":
            if args.len() > 0:
                return "lv_join(${obj}, ${args[0]})"
            return "lv_join(${obj}, std::string(\"\"))"
        elif method == "reverse":
            return "lv_reverse(${obj})"
        elif method == "keys":
            return "lv_keys(${obj})"
        elif method == "values":
            return "lv_values(${obj})"
        elif method == "has":
            return "(${obj}.count(${args.join(", ")}) > 0)"
        return ""

    // ── Method expression emission (inside class methods) ─────

    string fn emit_method_expr(Expr e):
        match e:
            Set(object, name, value):
                match object:
                    This(kw):
                        return "this->${name.lexeme} = ${this.emit_method_expr(value)}"
                    _:
                        return "${this.emit_method_expr(object)}.${name.lexeme} = ${this.emit_method_expr(value)}"
            Get(object, name):
                match object:
                    This(kw):
                        return "this->${name.lexeme}"
                    _:
                        return "${this.emit_method_expr(object)}.${name.lexeme}"
            This(keyword):
                return "(*this)"
            Grouping(inner):
                return "(${this.emit_method_expr(inner)})"
            Index(object, bracket, index):
                return "${this.emit_method_expr(object)}[${this.emit_method_expr(index)}]"
            IndexSet(object, bracket, index, value):
                return "${this.emit_method_expr(object)}[${this.emit_method_expr(index)}] = ${this.emit_method_expr(value)}"
            Vector(elements):
                if elements.len() == 0:
                    return "{}"
                vector[string] elems = []
                for el in elements:
                    elems.push(this.emit_method_expr(el))
                return "std::vector{${elems.join(", ")}}"
            Binary(left, op, right):
                string l = this.emit_method_expr(left)
                string r = this.emit_method_expr(right)
                string op_str = this.token_to_cpp_op(op)
                return "(${l} ${op_str} ${r})"
            Unary(op, right):
                string r = this.emit_method_expr(right)
                string op_str = this.token_to_cpp_op(op)
                return "(${op_str}${r})"
            Logical(left, op, right):
                string l = this.emit_method_expr(left)
                string r = this.emit_method_expr(right)
                string op_str = "&&"
                if op.token_type == TK_OR:
                    op_str = "||"
                return "${l} ${op_str} ${r}"
            Assign(name, value):
                return "${name.lexeme} = ${this.emit_method_expr(value)}"
            Call(callee, paren, args):
                return this.emit_call_expr(callee, args, true)
            Map(keys, values):
                vector[string] entries = []
                for i in 0..keys.len():
                    entries.push("{${this.emit_method_expr(keys[i])}, ${this.emit_method_expr(values[i])}}")
                return "{{${entries.join(", ")}}}"
            StaticGet(object, name):
                match object:
                    This(kw):
                        return "(*this)::${name.lexeme}"
                    _:
                        return "${this.emit_method_expr(object)}::${name.lexeme}"
            Cast(expr, target_type):
                string ex = this.emit_method_expr(expr)
                string t = this.emit_type(target_type)
                if this.is_dynamic_expression(expr):
                    return "std::any_cast<${t}>(${ex})"
                return "static_cast<${t}>(${ex})"
            Throw(expr):
                return "throw std::runtime_error(${this.emit_method_expr(expr)})"
            Literal(kind, value):
                return this.emit_literal(kind, value)
            _:
                return this.emit_expr(e)

    // ── Statement emission ────────────────────────────────────

    void fn emit_stmt(Stmt s):
        match s:
            None():
                int noop = 0
            ExprStmt(expr):
                this.output = this.output + "${this.indent()}${this.emit_expr(expr)};\n"
            Let(name, var_type, initializer, visibility):
                this.emit_let(name, var_type, initializer, false)
            Const(name, const_type, value, visibility):
                string cpp_type = this.emit_type(const_type)
                string val = this.emit_expr(value)
                this.output = this.output + "${this.indent()}const ${cpp_type} ${name.lexeme} = ${val};\n"
            Return(keyword, value):
                match value:
                    None():
                        this.output = this.output + "${this.indent()}return;\n"
                    _:
                        this.output = this.output + "${this.indent()}return ${this.emit_expr(value)};\n"
            If(condition, then_branch, else_branch):
                this.output = this.output + "${this.indent()}if (${this.emit_expr(condition)}) "
                this.emit_block_or_stmt(then_branch)
                match else_branch:
                    None():
                        int noop = 0
                    _:
                        this.output = this.output + "${this.indent()} else "
                        this.emit_block_or_stmt(else_branch)
            While(condition, body):
                this.output = this.output + "${this.indent()}while (${this.emit_expr(condition)}) "
                this.emit_block_or_stmt(body)
            For(item_name, collection, body):
                match collection:
                    Range(start, end):
                        this.output = this.output + "${this.indent()}for (int64_t ${item_name.lexeme} = ${this.emit_expr(start)}; ${item_name.lexeme} < ${this.emit_expr(end)}; ${item_name.lexeme}++) "
                        this.emit_block_or_stmt(body)
                    _:
                        match collection:
                            Variable(tok):
                                if this.is_dynamic_var(tok.lexeme):
                                    this.add_dynamic_var(item_name.lexeme)
                            _:
                                int noop = 0
                        this.output = this.output + "${this.indent()}for (auto& ${item_name.lexeme} : ${this.emit_expr(collection)}) "
                        this.emit_block_or_stmt(body)
            Block(statements):
                this.output = this.output + "${this.indent()}{\n"
                this.indent_level += 1
                for st in statements:
                    this.emit_stmt(st)
                this.indent_level -= 1
                this.output = this.output + "${this.indent()}}\n"
            Try(try_body, catch_body, exception_name):
                this.output = this.output + "${this.indent()}try "
                this.emit_block_or_stmt(try_body)
                string exc_name = "e"
                if exception_name != "":
                    exc_name = exception_name
                this.output = this.output + "${this.indent()} catch (const std::exception& ${exc_name}) "
                this.emit_block_or_stmt(catch_body)
            Function(name, params, return_type, body, is_inline, is_comptime, is_static, visibility):
                this.emit_function(name, params, return_type, body)
            Class(name, body, visibility):
                this.emit_class(name, body)
            Struct(name, body, visibility):
                this.emit_class(name, body)
            Enum(name, variants, visibility):
                this.emit_enum(name, variants)
            Match(expr, arm_patterns, arm_bodies):
                this.emit_match(expr, arm_patterns, arm_bodies)
            Namespace(name, body, visibility):
                this.output = this.output + "${this.indent()}// TODO: unsupported namespace\n"
            Import(path, alias):
                this.output = this.output + "${this.indent()}// TODO: unsupported import\n"
            Break(keyword):
                this.output = this.output + "${this.indent()}break;\n"
            Continue(keyword):
                this.output = this.output + "${this.indent()}continue;\n"
            _:
                int noop = 0

    void fn emit_let(Token name, TypeNode var_type, Expr initializer, bool in_method):
        string cpp_type = this.emit_type(var_type)
        if this.type_contains_dynamic(var_type):
            this.add_dynamic_var(name.lexeme)
        string init_str = ""
        match initializer:
            None():
                init_str = this.default_init(cpp_type)
            _:
                string val = ""
                if in_method:
                    val = this.emit_method_expr(initializer)
                else:
                    val = this.emit_expr(initializer)
                init_str = " = ${val}"
        this.output = this.output + "${this.indent()}${cpp_type} ${name.lexeme}${init_str};\n"

    void fn emit_block_or_stmt(Stmt s):
        match s:
            Block(stmts):
                this.output = this.output + "{\n"
                this.indent_level += 1
                for st in stmts:
                    this.emit_stmt(st)
                this.indent_level -= 1
                this.output = this.output + "${this.indent()}}\n"
            _:
                this.output = this.output + "{\n"
                this.indent_level += 1
                this.emit_stmt(s)
                this.indent_level -= 1
                this.output = this.output + "${this.indent()}}\n"

    void fn emit_method_block_or_stmt(Stmt s):
        match s:
            Block(stmts):
                this.output = this.output + "{\n"
                this.indent_level += 1
                for st in stmts:
                    this.emit_method_stmt(st)
                this.indent_level -= 1
                this.output = this.output + "${this.indent()}}\n"
            _:
                this.output = this.output + "{\n"
                this.indent_level += 1
                this.emit_method_stmt(s)
                this.indent_level -= 1
                this.output = this.output + "${this.indent()}}\n"

    void fn emit_function(Token name, vector[Param] params, TypeNode return_type, vector[Stmt] body):
        vector[string] saved_dynamic = this.dynamic_vars
        string ret_type = this.emit_type(return_type)
        vector[string] param_strs = []
        for p in params:
            param_strs.push("${this.emit_type(p.param_type)} ${p.name.lexeme}")
            match p.param_type:
                Dynamic():
                    this.add_dynamic_var(p.name.lexeme)
                _:
                    int noop = 0
        this.output = this.output + "${this.indent()}${ret_type} ${name.lexeme}(${param_strs.join(", ")}) {\n"
        this.indent_level += 1
        for st in body:
            this.emit_stmt(st)
        this.indent_level -= 1
        this.output = this.output + "${this.indent()}}\n\n"
        this.dynamic_vars = saved_dynamic

    // ── Method statement emission (inside class methods) ──────

    void fn emit_method_stmt(Stmt s):
        match s:
            ExprStmt(expr):
                this.output = this.output + "${this.indent()}${this.emit_method_expr(expr)};\n"
            Return(keyword, value):
                match value:
                    None():
                        this.output = this.output + "${this.indent()}return;\n"
                    _:
                        this.output = this.output + "${this.indent()}return ${this.emit_method_expr(value)};\n"
            If(condition, then_branch, else_branch):
                this.output = this.output + "${this.indent()}if (${this.emit_method_expr(condition)}) "
                this.emit_method_block_or_stmt(then_branch)
                match else_branch:
                    None():
                        int noop = 0
                    _:
                        this.output = this.output + "${this.indent()} else "
                        this.emit_method_block_or_stmt(else_branch)
            While(condition, body):
                this.output = this.output + "${this.indent()}while (${this.emit_method_expr(condition)}) "
                this.emit_method_block_or_stmt(body)
            For(item_name, collection, body):
                match collection:
                    Range(start, end):
                        this.output = this.output + "${this.indent()}for (int64_t ${item_name.lexeme} = ${this.emit_method_expr(start)}; ${item_name.lexeme} < ${this.emit_method_expr(end)}; ${item_name.lexeme}++) "
                        this.emit_method_block_or_stmt(body)
                    _:
                        match collection:
                            Variable(tok):
                                if this.is_dynamic_var(tok.lexeme):
                                    this.add_dynamic_var(item_name.lexeme)
                            _:
                                int noop = 0
                        this.output = this.output + "${this.indent()}for (auto& ${item_name.lexeme} : ${this.emit_method_expr(collection)}) "
                        this.emit_method_block_or_stmt(body)
            Let(name, var_type, initializer, visibility):
                this.emit_let(name, var_type, initializer, true)
            Const(name, const_type, value, visibility):
                string cpp_type = this.emit_type(const_type)
                string val = this.emit_method_expr(value)
                this.output = this.output + "${this.indent()}const ${cpp_type} ${name.lexeme} = ${val};\n"
            Block(stmts):
                this.output = this.output + "${this.indent()}{\n"
                this.indent_level += 1
                for st in stmts:
                    this.emit_method_stmt(st)
                this.indent_level -= 1
                this.output = this.output + "${this.indent()}}\n"
            Try(try_body, catch_body, exception_name):
                this.output = this.output + "${this.indent()}try "
                this.emit_method_block_or_stmt(try_body)
                string exc_name = "e"
                if exception_name != "":
                    exc_name = exception_name
                this.output = this.output + "${this.indent()} catch (const std::exception& ${exc_name}) "
                this.emit_method_block_or_stmt(catch_body)
            Match(expr, arm_patterns, arm_bodies):
                this.emit_match_in_method(expr, arm_patterns, arm_bodies)
            _:
                this.emit_stmt(s)

    // ── Class emission ────────────────────────────────────────

    void fn emit_class(Token name, vector[Stmt] body):
        vector[Stmt] init_body = []
        vector[Param] init_params = []
        bool has_init = false
        vector[Stmt] methods = []
        vector[string] let_field_names = []
        vector[string] let_field_types = []

        for st in body:
            match st:
                Function(fname, params, return_type, fbody, is_inline, is_comptime, is_static, visibility):
                    if fname.lexeme == "constructor":
                        has_init = true
                        init_body = fbody
                        init_params = params
                    else:
                        methods.push(st)
                Let(fname, var_type, init, visibility):
                    let_field_names.push(fname.lexeme)
                    let_field_types.push(this.emit_type(var_type))
                _:
                    int noop = 0

        vector[string] init_field_names = []
        vector[string] init_field_types = []
        if has_init:
            vector[string] param_names = []
            vector[string] param_types = []
            for p in init_params:
                param_names.push(p.name.lexeme)
                param_types.push(this.emit_type(p.param_type))
            vector[string] seen = []
            for st in init_body:
                match st:
                    ExprStmt(expr):
                        match expr:
                            Set(object, prop, value):
                                match object:
                                    This(kw):
                                        bool already = false
                                        for s in seen:
                                            if s == prop.lexeme:
                                                already = true
                                        if not already:
                                            seen.push(prop.lexeme)
                                            string cpp_type = this.infer_expr_type(value, param_names, param_types)
                                            init_field_names.push(prop.lexeme)
                                            init_field_types.push(cpp_type)
                                    _:
                                        int noop = 0
                            _:
                                int noop = 0
                    _:
                        int noop = 0

        this.output = this.output + "${this.indent()}struct ${name.lexeme} {\n"
        this.indent_level += 1

        for fi in 0..init_field_names.len():
            bool is_let = false
            for lfn in let_field_names:
                if lfn == init_field_names[fi]:
                    is_let = true
            if not is_let:
                this.output = this.output + "${this.indent()}${init_field_types[fi]} ${init_field_names[fi]};\n"

        for li in 0..let_field_names.len():
            this.output = this.output + "${this.indent()}${let_field_types[li]} ${let_field_names[li]};\n"

        if init_field_names.len() > 0 or let_field_names.len() > 0:
            this.output = this.output + "\n"

        if has_init:
            vector[string] param_strs = []
            for p in init_params:
                param_strs.push("${this.emit_type(p.param_type)} ${p.name.lexeme}")

            vector[string] init_list = []
            vector[Stmt] remaining_body = []
            for st in init_body:
                match st:
                    ExprStmt(expr):
                        bool handled = false
                        match expr:
                            Set(object, prop, value):
                                match object:
                                    This(kw):
                                        match value:
                                            Variable(tok):
                                                init_list.push("${prop.lexeme}(${tok.lexeme})")
                                                handled = true
                                            _:
                                                int noop = 0
                                    _:
                                        int noop = 0
                            _:
                                int noop = 0
                        if not handled:
                            remaining_body.push(st)
                    _:
                        remaining_body.push(st)

            if init_list.len() == 0:
                this.output = this.output + "${this.indent()}${name.lexeme}(${param_strs.join(", ")}) {\n"
            else:
                this.output = this.output + "${this.indent()}${name.lexeme}(${param_strs.join(", ")})\n"
                this.output = this.output + "${this.indent()}    : ${init_list.join(", ")} {\n"
            this.indent_level += 1
            for st in remaining_body:
                this.emit_method_stmt(st)
            this.indent_level -= 1
            this.output = this.output + "${this.indent()}}\n\n"

        for m in methods:
            match m:
                Function(mname, mparams, mret, mbody, is_inline, is_comptime, is_static, visibility):
                    vector[string] saved_dyn = this.dynamic_vars
                    string ret_type = this.emit_type(mret)
                    vector[string] mparam_strs = []
                    for p in mparams:
                        mparam_strs.push("${this.emit_type(p.param_type)} ${p.name.lexeme}")
                        match p.param_type:
                            Dynamic():
                                this.add_dynamic_var(p.name.lexeme)
                            _:
                                int noop = 0
                    if mname.lexeme == "destructor":
                        this.output = this.output + "${this.indent()}~${name.lexeme}() {\n"
                    else:
                        this.output = this.output + "${this.indent()}${ret_type} ${mname.lexeme}(${mparam_strs.join(", ")}) {\n"
                    this.indent_level += 1
                    for st in mbody:
                        this.emit_method_stmt(st)
                    this.indent_level -= 1
                    this.output = this.output + "${this.indent()}}\n\n"
                    this.dynamic_vars = saved_dyn
                _:
                    int noop = 0

        this.indent_level -= 1
        this.output = this.output + "${this.indent()}};\n\n"

    string fn infer_expr_type(Expr e, vector[string] param_names, vector[string] param_types):
        match e:
            Literal(kind, value):
                if kind == "int":
                    return "int64_t"
                elif kind == "float":
                    return "double"
                elif kind == "string":
                    return "std::string"
                elif kind == "bool":
                    return "bool"
                return "std::any"
            Variable(tok):
                for i in 0..param_names.len():
                    if param_names[i] == tok.lexeme:
                        if param_types[i] == "auto":
                            return "std::any"
                        return param_types[i]
                return "std::any"
            Binary(left, op, right):
                string lt = this.infer_expr_type(left, param_names, param_types)
                string rt = this.infer_expr_type(right, param_names, param_types)
                if lt == rt and lt != "std::any":
                    return lt
                return "std::any"
            Call(callee, paren, args):
                match callee:
                    Variable(tok):
                        if this.is_known_enum(tok.lexeme):
                            return tok.lexeme
                        for ci in 0..param_names.len():
                            if param_names[ci] == tok.lexeme:
                                return param_types[ci]
                        return tok.lexeme
                    _:
                        return "std::any"
            Vector(elements):
                return "std::vector<std::any>"
            _:
                return "std::any"

    // ── Enum emission ─────────────────────────────────────────

    void fn emit_enum(Token name, vector[EnumVariantNode] variants):
        string enum_name = name.lexeme
        this.known_enum_names.push(enum_name)
        this.known_enum_variants.push(variants)

        bool has_self_ref = false
        for v in variants:
            for ft in v.types:
                match ft:
                    Custom(n):
                        if n == enum_name:
                            has_self_ref = true
                    _:
                        int noop = 0

        if has_self_ref:
            this.output = this.output + "${this.indent()}struct ${enum_name};\n"

        this.output = this.output + "${this.indent()}struct ${enum_name} {\n"
        this.indent_level += 1

        for v in variants:
            if v.types.len() > 0:
                this.output = this.output + "${this.indent()}struct ${v.name.lexeme} { "
                for fi in 0..v.types.len():
                    string cpp_type = this.emit_type(v.types[fi])
                    string fname = v.field_names[fi]
                    match v.types[fi]:
                        Custom(n):
                            if n == enum_name:
                                cpp_type = "std::shared_ptr<${enum_name}>"
                        _:
                            int noop = 0
                    this.output = this.output + "${cpp_type} ${fname}; "
                this.output = this.output + "};\n"
            else:
                this.output = this.output + "${this.indent()}struct ${v.name.lexeme} {};\n"
        this.output = this.output + "\n"

        this.output = this.output + "${this.indent()}std::string _tag;\n"

        vector[string] variant_inner_types = []
        for v in variants:
            variant_inner_types.push("${enum_name}::${v.name.lexeme}")

        this.output = this.output + "${this.indent()}std::variant<${variant_inner_types.join(", ")}> _data;\n"
        this.output = this.output + "\n"

        for v in variants:
            string vname = v.name.lexeme
            if v.types.len() == 0:
                this.output = this.output + "${this.indent()}static ${enum_name} make_${vname}() { return {\"${vname}\", ${vname}{}}; }\n"
            else:
                vector[string] params = []
                vector[string] field_inits = []
                for fi in 0..v.types.len():
                    string cpp_type = this.emit_type(v.types[fi])
                    string fname = v.field_names[fi]
                    bool is_self_ref = false
                    match v.types[fi]:
                        Custom(n):
                            if n == enum_name:
                                is_self_ref = true
                        _:
                            int noop = 0
                    if is_self_ref:
                        params.push("${enum_name} ${fname}")
                        field_inits.push("std::make_shared<${enum_name}>(std::move(${fname}))")
                    else:
                        params.push("${cpp_type} ${fname}")
                        field_inits.push(fname)
                this.output = this.output + "${this.indent()}static ${enum_name} make_${vname}(${params.join(", ")}) { return {\"${vname}\", ${vname}{${field_inits.join(", ")}}}; }\n"
        this.output = this.output + "\n"

        this.output = this.output + "${this.indent()}std::string operator[](const std::string& key) const {\n"
        this.indent_level += 1
        this.output = this.output + "${this.indent()}if (key == \"_tag\") return _tag;\n"
        this.output = this.output + "${this.indent()}return \"\";\n"
        this.indent_level -= 1
        this.output = this.output + "${this.indent()}}\n"

        this.indent_level -= 1
        this.output = this.output + "${this.indent()}};\n\n"

        this.output = this.output + "void print(const ${enum_name}& e) { std::cout << \"${enum_name}(\" << e._tag << \")\" << std::endl; }\n"
        this.output = this.output + "std::string operator+(const std::string& s, const ${enum_name}& e) { return s + e._tag; }\n"
        this.output = this.output + "std::string operator+(const ${enum_name}& e, const std::string& s) { return e._tag + s; }\n\n"

    // ── Match emission ────────────────────────────────────────

    void fn emit_match(Expr expr, vector[MatchArm] arm_patterns, vector[Stmt] arm_bodies):
        this.emit_match_impl(expr, arm_patterns, arm_bodies, false)

    void fn emit_match_in_method(Expr expr, vector[MatchArm] arm_patterns, vector[Stmt] arm_bodies):
        this.emit_match_impl(expr, arm_patterns, arm_bodies, true)

    void fn emit_match_impl(Expr expr, vector[MatchArm] arm_patterns, vector[Stmt] arm_bodies, bool in_method):
        string match_val = ""
        if in_method:
            match_val = this.emit_method_expr(expr)
        else:
            match_val = this.emit_expr(expr)
        string temp = "_match_${this.temp_counter}"
        this.temp_counter += 1

        this.output = this.output + "${this.indent()}{\n"
        this.indent_level += 1
        this.output = this.output + "${this.indent()}auto& ${temp} = ${match_val};\n"

        bool first = true
        for ai in 0..arm_patterns.len():
            auto arm = arm_patterns[ai]
            Stmt arm_body = arm_bodies[ai]
            if arm.pattern_name == "_":
                if first:
                    this.output = this.output + "${this.indent()}{\n"
                else:
                    this.output = this.output + "${this.indent()}else {\n"
                this.indent_level += 1
                this.emit_arm_body(arm_body, in_method)
                this.indent_level -= 1
                this.output = this.output + "${this.indent()}}\n"
            else:
                string keyword = "if"
                if not first:
                    keyword = "else if"
                first = false
                string ename = this.find_enum_for_variant(arm.pattern_name)
                if ename != "":
                    this.output = this.output + "${this.indent()}${keyword} (std::holds_alternative<${ename}::${arm.pattern_name}>(${temp}._data)) {\n"
                else:
                    this.output = this.output + "${this.indent()}${keyword} (${temp}._tag == \"${arm.pattern_name}\") {\n"
                this.indent_level += 1

                if arm.bindings.len() > 0:
                    if ename != "":
                        this.output = this.output + "${this.indent()}auto& _v = std::get<${ename}::${arm.pattern_name}>(${temp}._data);\n"
                        auto vinfo = this.get_variant_info(ename, arm.pattern_name)
                        for bi in 0..arm.bindings.len():
                            if bi < vinfo.field_names.len():
                                string field_name = vinfo.field_names[bi]
                                bool is_self_ref = false
                                if bi < vinfo.types.len():
                                    match vinfo.types[bi]:
                                        Custom(n):
                                            if n == ename:
                                                is_self_ref = true
                                        _:
                                            int noop = 0
                                if is_self_ref:
                                    this.output = this.output + "${this.indent()}auto& ${arm.bindings[bi]} = *_v.${field_name};\n"
                                else:
                                    this.output = this.output + "${this.indent()}auto& ${arm.bindings[bi]} = _v.${field_name};\n"

                this.emit_arm_body(arm_body, in_method)
                this.indent_level -= 1
                this.output = this.output + "${this.indent()}}\n"

        this.indent_level -= 1
        this.output = this.output + "${this.indent()}}\n"

    void fn emit_arm_body(Stmt arm_body, bool in_method):
        match arm_body:
            Block(stmts):
                for st in stmts:
                    if in_method:
                        this.emit_method_stmt(st)
                    else:
                        this.emit_stmt(st)
            _:
                if in_method:
                    this.emit_method_stmt(arm_body)
                else:
                    this.emit_stmt(arm_body)

    // ── Main entry point ──────────────────────────────────────

    string fn generate(vector[Stmt] stmts):
        this.declarations = "#include \"lavina.h\"\n\n"

        for stmt in stmts:
            match stmt:
                Function(name, params, return_type, body, is_inline, is_comptime, is_static, visibility):
                    if name.lexeme == "main":
                        this.has_main = true
                        this.output = this.output + "int main(int argc, char* argv[]) {\n"
                        this.output = this.output + "    for (int i = 0; i < argc; i++) _lv_args.push_back(argv[i]);\n"
                        this.indent_level = 1
                        for s in body:
                            this.emit_stmt(s)
                        this.indent_level = 0
                        this.output = this.output + "}\n"
                        this.declarations = this.declarations + this.output
                        this.output = ""
                    else:
                        this.emit_stmt(stmt)
                        this.declarations = this.declarations + this.output
                        this.output = ""
                _:
                    this.emit_stmt(stmt)
                    this.declarations = this.declarations + this.output
                    this.output = ""

        return this.declarations
