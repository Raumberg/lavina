// ═══════════════════════════════════════════════════════════════
//  Lavina Bootstrap Compiler — Parser
//  Translates a flat token list into an AST.
// ═══════════════════════════════════════════════════════════════

// ── Type AST ─────────────────────────────────────────────────

enum TypeNode:
    null None
    null Int
    null Float
    null Str
    null Bool
    null Void
    null Auto
    null Dynamic
    null NullType
    Custom(string name)
    Array(TypeNode inner)
    Dict(TypeNode key_type, TypeNode value_type)
    Nullable(TypeNode inner)

// ── Helper structs ───────────────────────────────────────────

class Param:
    Token name
    TypeNode param_type
    void fn __init__(Token name, TypeNode param_type):
        this.name = name
        this.param_type = param_type

class EnumVariantNode:
    Token name
    vector[TypeNode] types
    void fn __init__(Token name, vector[TypeNode] types):
        this.name = name
        this.types = types

// ── Expression AST ───────────────────────────────────────────

enum Expr:
    null None
    Literal(string kind, string value)
    Unary(Token op, Expr right)
    Binary(Expr left, Token op, Expr right)
    Grouping(Expr inner)
    Variable(Token name)
    Assign(Token name, Expr value)
    Logical(Expr left, Token op, Expr right)
    Call(Expr callee, Token paren, vector[Expr] args)
    Index(Expr object, Token bracket, Expr index)
    Vector(vector[Expr] elements)
    Map(vector[Expr] keys, vector[Expr] values)
    Get(Expr object, Token name)
    Set(Expr object, Token name, Expr value)
    StaticGet(Expr object, Token name)
    This(Token keyword)
    Cast(Expr expr, TypeNode target_type)
    Throw(Expr expr)

// ── Statement AST ────────────────────────────────────────────

enum Stmt:
    null None
    ExprStmt(Expr expr)
    Let(Token name, TypeNode var_type, Expr initializer, string visibility)
    Const(Token name, TypeNode const_type, Expr value, string visibility)
    Return(Token keyword, Expr value)
    If(Expr condition, Stmt then_branch, Stmt else_branch)
    While(Expr condition, Stmt body)
    For(Token item_name, Expr collection, Stmt body)
    Block(vector[Stmt] statements)
    Try(Stmt try_body, Stmt catch_body, string exception_name)
    Function(Token name, vector[Param] params, TypeNode return_type, vector[Stmt] body, bool is_inline, bool is_comptime, bool is_static, string visibility)
    Class(Token name, vector[Stmt] body, string visibility)
    Struct(Token name, vector[Stmt] body, string visibility)
    Enum(Token name, vector[EnumVariantNode] variants, string visibility)
    Namespace(Token name, vector[Stmt] body, string visibility)
    Import(vector[Token] path, string alias)

// ── Parser class ──────────────────────────────────────────────

class Parser:
    vector[Token] tokens
    int current
    bool in_class_body

    void fn __init__(vector[Token] tokens):
        this.tokens = tokens
        this.current = 0
        this.in_class_body = false

    // ── Helpers ─────────────────────────────────────────────

    bool fn is_at_end():
        return this.peek().token_type == TK_EOF

    Token fn peek():
        return this.tokens[this.current]

    Token fn peek_at(int offset):
        if this.current + offset >= this.tokens.len():
            return this.tokens[this.tokens.len() - 1]
        return this.tokens[this.current + offset]

    Token fn previous():
        return this.tokens[this.current - 1]

    Token fn advance():
        if this.is_at_end() == false:
            this.current = this.current + 1
        return this.previous()

    Token fn consume(string tk_type, string message):
        if this.check(tk_type):
            return this.advance()
        auto t = this.peek()
        throw message + " Got " + t.token_type + " at " + t.line + ":" + t.col

    bool fn check(string tk_type):
        if this.is_at_end():
            return false
        return this.peek().token_type == tk_type

    bool fn match_any(vector[string] types):
        for t in types:
            if this.check(t):
                this.advance()
                return true
        return false

    void fn skip_formatting():
        while this.match_any([TK_NEWLINE, TK_INDENT, TK_DEDENT]):
            int noop = 0

    bool fn is_type_at_pos(int pos):
        auto t = this.peek_at(pos).token_type
        if t == TK_INT_TYPE:
            return true
        if t == TK_FLOAT_TYPE:
            return true
        if t == TK_STRING_TYPE:
            return true
        if t == TK_BOOL:
            return true
        if t == TK_VOID:
            return true
        if t == TK_AUTO:
            return true
        if t == TK_DYNAMIC:
            return true
        if t == TK_VECTOR:
            return true
        if t == TK_HASHMAP:
            return true
        if t == TK_IDENTIFIER:
            return true
        return false

    bool fn check_function_start():
        int offset = 0
        if this.is_type_at_pos(offset) == false:
            return false
        auto tt = this.peek_at(offset).token_type
        offset = offset + 1
        if tt == TK_VECTOR:
            offset = offset + 3
        else if tt == TK_HASHMAP:
            offset = offset + 5
        if this.peek_at(offset).token_type == TK_QUESTION:
            offset = offset + 1
        bool still_modifiers = true
        while offset < this.tokens.len() and still_modifiers:
            auto mt = this.peek_at(offset).token_type
            if mt == TK_INLINE or mt == TK_COMPTIME:
                offset = offset + 1
            else:
                still_modifiers = false
        return this.peek_at(offset).token_type == TK_FN

    // ── Type parsing ────────────────────────────────────────

    TypeNode fn parse_type():
        TypeNode t = TypeNode::None()
        if this.match_any([TK_INT_TYPE]):
            t = TypeNode::Int()
        else if this.match_any([TK_FLOAT_TYPE]):
            t = TypeNode::Float()
        else if this.match_any([TK_STRING_TYPE]):
            t = TypeNode::Str()
        else if this.match_any([TK_BOOL]):
            t = TypeNode::Bool()
        else if this.match_any([TK_VOID]):
            t = TypeNode::Void()
        else if this.match_any([TK_AUTO]):
            t = TypeNode::Auto()
        else if this.match_any([TK_DYNAMIC]):
            t = TypeNode::Dynamic()
        else if this.match_any([TK_NULL]):
            t = TypeNode::NullType()
        else if this.match_any([TK_VECTOR]):
            this.consume(TK_LEFT_BRACKET, "Expect '[' after 'vector'.")
            TypeNode inner = this.parse_type()
            this.consume(TK_RIGHT_BRACKET, "Expect ']' after vector type.")
            t = TypeNode::Array(inner)
        else if this.match_any([TK_HASHMAP]):
            this.consume(TK_LEFT_BRACKET, "Expect '[' after 'hashmap'.")
            TypeNode k = this.parse_type()
            this.consume(TK_COMMA, "Expect ',' between key and value types.")
            TypeNode v = this.parse_type()
            this.consume(TK_RIGHT_BRACKET, "Expect ']' after hashmap types.")
            t = TypeNode::Dict(k, v)
        else if this.match_any([TK_IDENTIFIER]):
            t = TypeNode::Custom(this.previous().lexeme)
        else:
            auto tok = this.peek()
            throw "Expect type. Got " + tok.token_type + " at " + tok.line + ":" + tok.col

        if this.match_any([TK_QUESTION]):
            t = TypeNode::Nullable(t)
        return t

    // ── Expression parsing ──────────────────────────────────

    Expr fn expression():
        return this.assignment()

    Expr fn assignment():
        Expr expr = this.logical_or()
        if this.match_any([TK_EQUAL]):
            Expr value = this.assignment()
            match expr:
                Variable(name):
                    return Expr::Assign(name, value)
                Get(object, name):
                    return Expr::Set(object, name, value)
                _:
                    throw "Invalid assignment target."
        return expr

    Expr fn logical_or():
        Expr expr = this.logical_and()
        while this.match_any([TK_OR]):
            auto op = this.previous()
            Expr right = this.logical_and()
            expr = Expr::Logical(expr, op, right)
        return expr

    Expr fn logical_and():
        Expr expr = this.equality()
        while this.match_any([TK_AND]):
            auto op = this.previous()
            Expr right = this.equality()
            expr = Expr::Logical(expr, op, right)
        return expr

    Expr fn equality():
        Expr expr = this.comparison()
        while this.match_any([TK_BANG_EQUAL, TK_EQUAL_EQUAL]):
            auto op = this.previous()
            Expr right = this.comparison()
            expr = Expr::Binary(expr, op, right)
        return expr

    Expr fn comparison():
        Expr expr = this.term()
        while this.match_any([TK_GREATER, TK_GREATER_EQUAL, TK_LESS, TK_LESS_EQUAL]):
            auto op = this.previous()
            Expr right = this.term()
            expr = Expr::Binary(expr, op, right)
        return expr

    Expr fn term():
        Expr expr = this.factor()
        while this.match_any([TK_MINUS, TK_PLUS]):
            auto op = this.previous()
            Expr right = this.factor()
            expr = Expr::Binary(expr, op, right)
        return expr

    Expr fn factor():
        Expr expr = this.unary()
        while this.match_any([TK_SLASH, TK_STAR]):
            auto op = this.previous()
            Expr right = this.unary()
            expr = Expr::Binary(expr, op, right)
        return expr

    Expr fn unary():
        if this.match_any([TK_BANG, TK_MINUS]):
            auto op = this.previous()
            Expr right = this.unary()
            return Expr::Unary(op, right)
        return this.call()

    Expr fn call():
        Expr expr = this.primary()
        bool more = true
        while more:
            if this.match_any([TK_LEFT_PAREN]):
                expr = this.finish_call(expr)
            else if this.match_any([TK_LEFT_BRACKET]):
                Expr index = this.expression()
                auto bracket = this.consume(TK_RIGHT_BRACKET, "Expect ']' after index.")
                expr = Expr::Index(expr, bracket, index)
            else if this.match_any([TK_DOT]):
                auto name = this.consume(TK_IDENTIFIER, "Expect property name after '.'.")
                expr = Expr::Get(expr, name)
            else if this.match_any([TK_DOUBLE_COLON]):
                auto name = this.consume(TK_IDENTIFIER, "Expect member name after '::'.")
                expr = Expr::StaticGet(expr, name)
            else:
                more = false
        return expr

    Expr fn finish_call(Expr callee):
        match callee:
            Variable(name):
                if name.lexeme == "cast":
                    Expr expr = this.expression()
                    this.consume(TK_COMMA, "Expect ',' after value in cast().")
                    TypeNode target = this.parse_type()
                    this.consume(TK_RIGHT_PAREN, "Expect ')' after type in cast().")
                    return Expr::Cast(expr, target)
            _:
                int noop = 0

        vector[Expr] args = []
        if this.check(TK_RIGHT_PAREN) == false:
            args.push(this.expression())
            while this.match_any([TK_COMMA]):
                args.push(this.expression())
        auto paren = this.consume(TK_RIGHT_PAREN, "Expect ')' after arguments.")
        return Expr::Call(callee, paren, args)

    Expr fn primary():
        if this.match_any([TK_FALSE]):
            return Expr::Literal("bool", "false")
        if this.match_any([TK_TRUE]):
            return Expr::Literal("bool", "true")
        if this.match_any([TK_NULL]):
            return Expr::Literal("null", "null")
        if this.match_any([TK_INT]):
            return Expr::Literal("int", this.previous().lexeme)
        if this.match_any([TK_FLOAT]):
            return Expr::Literal("float", this.previous().lexeme)
        if this.match_any([TK_STRING]):
            return Expr::Literal("string", this.previous().lexeme)
        if this.match_any([TK_IDENTIFIER]):
            return Expr::Variable(this.previous())
        if this.match_any([TK_THIS]):
            return Expr::This(this.previous())
        if this.match_any([TK_LEFT_PAREN]):
            Expr expr = this.expression()
            this.consume(TK_RIGHT_PAREN, "Expect ')' after expression.")
            return Expr::Grouping(expr)
        if this.match_any([TK_LEFT_BRACKET]):
            vector[Expr] elements = []
            this.skip_formatting()
            if this.check(TK_RIGHT_BRACKET) == false:
                this.skip_formatting()
                elements.push(this.expression())
                this.skip_formatting()
                while this.match_any([TK_COMMA]):
                    this.skip_formatting()
                    elements.push(this.expression())
                    this.skip_formatting()
            this.skip_formatting()
            this.consume(TK_RIGHT_BRACKET, "Expect ']' after vector literal.")
            return Expr::Vector(elements)
        if this.match_any([TK_LEFT_BRACE]):
            vector[Expr] keys = []
            vector[Expr] values = []
            this.skip_formatting()
            if this.check(TK_RIGHT_BRACE) == false:
                this.skip_formatting()
                Expr key = this.expression()
                this.skip_formatting()
                this.consume(TK_COLON, "Expect ':' after map key.")
                this.skip_formatting()
                Expr value = this.expression()
                this.skip_formatting()
                keys.push(key)
                values.push(value)
                while this.match_any([TK_COMMA]):
                    this.skip_formatting()
                    key = this.expression()
                    this.skip_formatting()
                    this.consume(TK_COLON, "Expect ':' after map key.")
                    this.skip_formatting()
                    value = this.expression()
                    this.skip_formatting()
                    keys.push(key)
                    values.push(value)
            this.skip_formatting()
            this.consume(TK_RIGHT_BRACE, "Expect '}' after map literal.")
            return Expr::Map(keys, values)

        auto t = this.peek()
        throw "Expect expression. Got " + t.token_type + " at " + t.line + ":" + t.col

    // ── Statement parsing ───────────────────────────────────

    Stmt fn statement():
        if this.match_any([TK_IF]):
            return this.if_statement()
        if this.match_any([TK_WHILE]):
            return this.while_statement()
        if this.match_any([TK_FOR]):
            return this.for_statement()
        if this.match_any([TK_RETURN]):
            return this.return_statement()
        if this.match_any([TK_THROW]):
            return this.throw_statement()
        if this.match_any([TK_MATCH]):
            return this.match_statement()
        return this.expression_statement()

    Stmt fn throw_statement():
        Expr expr = this.expression()
        this.match_any([TK_SEMICOLON, TK_NEWLINE])
        return Stmt::ExprStmt(Expr::Throw(expr))

    Stmt fn if_statement():
        Expr condition = this.expression()
        this.consume(TK_COLON, "Expect ':' after if condition.")
        Stmt then_branch = Stmt::Block(this.block())

        Stmt else_branch = Stmt::None()
        if this.match_any([TK_ELSE]):
            if this.match_any([TK_COLON]):
                else_branch = Stmt::Block(this.block())
            else if this.check(TK_IF):
                else_branch = this.declaration()
        return Stmt::If(condition, then_branch, else_branch)

    Stmt fn while_statement():
        Expr condition = this.expression()
        this.consume(TK_COLON, "Expect ':' after while condition.")
        Stmt body = Stmt::Block(this.block())
        return Stmt::While(condition, body)

    Stmt fn for_statement():
        auto item_name = this.consume(TK_IDENTIFIER, "Expect variable name after 'for'.")
        this.consume(TK_IN, "Expect 'in' after variable name.")
        Expr collection = this.expression()
        this.consume(TK_COLON, "Expect ':' after for loop header.")
        Stmt body = Stmt::Block(this.block())
        return Stmt::For(item_name, collection, body)

    Stmt fn return_statement():
        auto keyword = this.previous()
        Expr value = Expr::None()
        if this.check(TK_NEWLINE) == false and this.check(TK_DEDENT) == false and this.is_at_end() == false:
            value = this.expression()
        this.match_any([TK_NEWLINE])
        return Stmt::Return(keyword, value)

    Stmt fn match_statement():
        Expr expr = this.expression()
        this.consume(TK_COLON, "Expect ':' after match expression.")
        this.match_any([TK_NEWLINE])
        this.consume(TK_INDENT, "Expect indentation to start match body.")

        vector[Stmt] arms = []
        while this.check(TK_DEDENT) == false and this.is_at_end() == false:
            if this.match_any([TK_NEWLINE]):
                int noop = 0
            else:
                arms.push(this.declaration())

        this.consume(TK_DEDENT, "Expect dedent to end match body.")
        return Stmt::Block(arms)

    vector[Stmt] fn block():
        this.match_any([TK_NEWLINE])
        this.consume(TK_INDENT, "Expect indentation to start a block.")

        vector[Stmt] statements = []
        while this.check(TK_DEDENT) == false and this.is_at_end() == false:
            if this.match_any([TK_NEWLINE]):
                int noop = 0
            else:
                statements.push(this.declaration())
        this.consume(TK_DEDENT, "Expect dedent to end a block.")
        return statements

    Stmt fn expression_statement():
        Expr expr = this.expression()
        this.match_any([TK_SEMICOLON, TK_NEWLINE])
        return Stmt::ExprStmt(expr)

    // ── Declaration parsing ─────────────────────────────────

    Stmt fn var_declaration(string visibility):
        TypeNode var_type = this.parse_type()
        auto name = this.consume(TK_IDENTIFIER, "Expect variable name after type.")

        Expr initializer = Expr::None()
        if this.match_any([TK_EQUAL]):
            initializer = this.expression()
        this.match_any([TK_SEMICOLON, TK_NEWLINE])
        return Stmt::Let(name, var_type, initializer, visibility)

    Stmt fn const_declaration(string visibility):
        TypeNode const_type = this.parse_type()
        auto name = this.consume(TK_IDENTIFIER, "Expect constant name after type.")
        this.consume(TK_EQUAL, "Const declaration must have an initializer.")
        Expr value = this.expression()
        this.match_any([TK_SEMICOLON, TK_NEWLINE])
        return Stmt::Const(name, const_type, value, visibility)

    Stmt fn function_declaration(string visibility, bool is_static):
        TypeNode return_type = this.parse_type()

        bool is_inline = false
        bool is_comptime = false
        while this.match_any([TK_INLINE, TK_COMPTIME]):
            if this.previous().token_type == TK_INLINE:
                is_inline = true
            if this.previous().token_type == TK_COMPTIME:
                is_comptime = true

        this.consume(TK_FN, "Expect 'fn' keyword after return type.")
        auto name = this.consume(TK_IDENTIFIER, "Expect function name.")

        this.consume(TK_LEFT_PAREN, "Expect '(' after function name.")
        vector[Param] params = []
        if this.check(TK_RIGHT_PAREN) == false:
            TypeNode param_type = this.parse_type()
            auto param_name = this.consume(TK_IDENTIFIER, "Expect parameter name.")
            params.push(Param(param_name, param_type))
            while this.match_any([TK_COMMA]):
                param_type = this.parse_type()
                param_name = this.consume(TK_IDENTIFIER, "Expect parameter name.")
                params.push(Param(param_name, param_type))
        this.consume(TK_RIGHT_PAREN, "Expect ')' after parameters.")

        this.consume(TK_COLON, "Expect ':' before function body.")
        vector[Stmt] body = this.block()
        return Stmt::Function(name, params, return_type, body, is_inline, is_comptime, is_static, visibility)

    Stmt fn class_declaration(string visibility):
        auto name = this.consume(TK_IDENTIFIER, "Expect class name.")
        this.consume(TK_COLON, "Expect ':' after class name.")
        auto old = this.in_class_body
        this.in_class_body = true
        auto body = this.block()
        this.in_class_body = old
        return Stmt::Class(name, body, visibility)

    Stmt fn struct_declaration(string visibility):
        auto name = this.consume(TK_IDENTIFIER, "Expect struct name.")
        this.consume(TK_COLON, "Expect ':' after struct name.")
        auto old = this.in_class_body
        this.in_class_body = true
        auto body = this.block()
        this.in_class_body = old
        return Stmt::Struct(name, body, visibility)

    Stmt fn enum_declaration(string visibility):
        auto name = this.consume(TK_IDENTIFIER, "Expect enum name.")
        this.consume(TK_COLON, "Expect ':' after enum name.")

        this.match_any([TK_NEWLINE])
        this.consume(TK_INDENT, "Expect indentation to start enum body.")

        vector[EnumVariantNode] variants = []
        while this.check(TK_DEDENT) == false and this.is_at_end() == false:
            if this.match_any([TK_NEWLINE]):
                int noop = 0
            else if this.check(TK_IDENTIFIER) and this.peek_at(1).token_type == TK_LEFT_PAREN:
                auto vname = this.consume(TK_IDENTIFIER, "Expect variant name.")
                this.consume(TK_LEFT_PAREN, "Expect '(' after variant name.")
                vector[TypeNode] fields = []
                if this.check(TK_RIGHT_PAREN) == false:
                    fields.push(this.parse_type())
                    this.consume(TK_IDENTIFIER, "Expect field name.")
                    while this.match_any([TK_COMMA]):
                        fields.push(this.parse_type())
                        this.consume(TK_IDENTIFIER, "Expect field name.")
                this.consume(TK_RIGHT_PAREN, "Expect ')' after variant fields.")
                variants.push(EnumVariantNode(vname, fields))
                this.match_any([TK_NEWLINE])
            else:
                TypeNode vtype = this.parse_type()
                auto vname = this.consume(TK_IDENTIFIER, "Expect variant name.")
                vector[TypeNode] types = []
                if vtype._tag != "NullType" and vtype._tag != "Void":
                    types.push(vtype)
                variants.push(EnumVariantNode(vname, types))
                this.match_any([TK_NEWLINE])

        this.consume(TK_DEDENT, "Expect dedent to end enum body.")
        return Stmt::Enum(name, variants, visibility)

    Stmt fn import_statement():
        vector[Token] path = []
        path.push(this.consume(TK_IDENTIFIER, "Expect module name."))
        while this.match_any([TK_DOUBLE_COLON]):
            path.push(this.consume(TK_IDENTIFIER, "Expect module name."))

        string alias = ""
        if this.match_any([TK_AS]):
            alias = this.consume(TK_IDENTIFIER, "Expect alias name after 'as'.").lexeme
        this.match_any([TK_SEMICOLON, TK_NEWLINE])
        return Stmt::Import(path, alias)

    Stmt fn namespace_statement(string visibility):
        auto name = this.consume(TK_IDENTIFIER, "Expect namespace name.")
        this.consume(TK_COLON, "Expect ':' after namespace name.")
        auto body = this.block()
        return Stmt::Namespace(name, body, visibility)

    Stmt fn try_statement():
        this.consume(TK_COLON, "Expect ':' after 'try'.")
        Stmt try_body = Stmt::Block(this.block())

        this.consume(TK_CATCH, "Expect 'catch' after 'try' block.")
        string exception_name = ""
        if this.match_any([TK_IDENTIFIER]):
            exception_name = this.previous().lexeme
        this.consume(TK_COLON, "Expect ':' after 'catch'.")
        Stmt catch_body = Stmt::Block(this.block())
        return Stmt::Try(try_body, catch_body, exception_name)

    Stmt fn declaration():
        string visibility = "public"
        if this.match_any([TK_PRIVATE]):
            visibility = "private"
        else if this.match_any([TK_PUBLIC]):
            visibility = "public"

        bool is_static = this.match_any([TK_STATIC])

        while this.check(TK_HASH):
            while this.check(TK_NEWLINE) == false and this.is_at_end() == false:
                this.advance()
            this.match_any([TK_NEWLINE])

        if this.match_any([TK_IMPORT]):
            return this.import_statement()

        if this.match_any([TK_NAMESPACE]):
            return this.namespace_statement(visibility)

        if this.match_any([TK_CLASS]):
            return this.class_declaration(visibility)

        if this.match_any([TK_STRUCT]):
            return this.struct_declaration(visibility)

        if this.match_any([TK_ENUM]):
            return this.enum_declaration(visibility)

        if this.match_any([TK_TRY]):
            return this.try_statement()

        if this.match_any([TK_CONST]):
            return this.const_declaration(visibility)

        if this.is_type_at_pos(0):
            int next_pos = 1
            auto current_type = this.peek().token_type
            if current_type == TK_VECTOR:
                next_pos = 4
            else if current_type == TK_HASHMAP:
                next_pos = 6

            if this.peek_at(next_pos).token_type == TK_QUESTION:
                next_pos = next_pos + 1

            auto next_token = this.peek_at(next_pos).token_type
            if next_token == TK_IDENTIFIER or next_token == TK_FN or next_token == TK_INLINE or next_token == TK_COMPTIME:
                if this.check_function_start():
                    return this.function_declaration(visibility, is_static)
                if this.in_class_body == false:
                    int eq_pos = next_pos + 1
                    if this.peek_at(eq_pos).token_type != TK_EQUAL:
                        auto tok = this.peek_at(next_pos)
                        throw "Bare field declarations are only allowed inside class/struct at " + tok.line + ":" + tok.col
                return this.var_declaration(visibility)

        return this.statement()

    // ── Main entry point ────────────────────────────────────

    vector[Stmt] fn parse_program():
        vector[Stmt] statements = []
        while this.is_at_end() == false:
            if this.match_any([TK_NEWLINE]):
                int noop = 0
            else:
                statements.push(this.declaration())
        return statements


// ═══════════════════════════════════════════════════════════════
//  Test: parse a simple expression
// ═══════════════════════════════════════════════════════════════

void fn main():
    test_scanner()

    auto parser_test_source = "1 + 2 * 3\n"
    auto parser_test_scanner = Scanner(parser_test_source)
    parser_test_scanner.scan_tokens()

    auto parser = Parser(parser_test_scanner.tokens)
    vector[Stmt] stmts = parser.parse_program()

    print("Parsed statements: " + stmts.len())
    for stmt in stmts:
        match stmt:
            ExprStmt(expr):
                match expr:
                    Binary(left, op, right):
                        print("Binary: " + op.lexeme)
                        match right:
                            Binary(rl, rop, rr):
                                print("  Right is Binary: " + rop.lexeme)
                                print("OK: precedence correct (1 + (2 * 3))")
                            _:
                                int noop = 0
                    _:
                        int noop = 0
            _:
                int noop = 0
