// ═══════════════════════════════════════════════════════════════
//  Lavina Bootstrap Compiler — Parser
//  Translates a flat token list into an AST.
// ═══════════════════════════════════════════════════════════════

// ── Expression AST nodes ──────────────────────────────────────

class LiteralExpr:
    string tag
    string kind
    string value
    void fn __init__(string kind, string value):
        this.tag = "Literal"
        this.kind = kind
        this.value = value

class UnaryExpr:
    string tag
    dynamic op
    dynamic right
    void fn __init__(dynamic op, dynamic right):
        this.tag = "Unary"
        this.op = op
        this.right = right

class BinaryExpr:
    string tag
    dynamic left
    dynamic op
    dynamic right
    void fn __init__(dynamic left, dynamic op, dynamic right):
        this.tag = "Binary"
        this.left = left
        this.op = op
        this.right = right

class GroupingExpr:
    string tag
    dynamic expr
    void fn __init__(dynamic expr):
        this.tag = "Grouping"
        this.expr = expr

class VariableExpr:
    string tag
    dynamic name
    void fn __init__(dynamic name):
        this.tag = "Variable"
        this.name = name

class AssignExpr:
    string tag
    dynamic name
    dynamic value
    void fn __init__(dynamic name, dynamic value):
        this.tag = "Assign"
        this.name = name
        this.value = value

class LogicalExpr:
    string tag
    dynamic left
    dynamic op
    dynamic right
    void fn __init__(dynamic left, dynamic op, dynamic right):
        this.tag = "Logical"
        this.left = left
        this.op = op
        this.right = right

class CallExpr:
    string tag
    dynamic callee
    dynamic paren
    vector[dynamic] args
    void fn __init__(dynamic callee, dynamic paren, vector[dynamic] args):
        this.tag = "Call"
        this.callee = callee
        this.paren = paren
        this.args = args

class IndexExpr:
    string tag
    dynamic object
    dynamic bracket
    dynamic index
    void fn __init__(dynamic object, dynamic bracket, dynamic index):
        this.tag = "Index"
        this.object = object
        this.bracket = bracket
        this.index = index

class VectorExpr:
    string tag
    vector[dynamic] elements
    void fn __init__(vector[dynamic] elements):
        this.tag = "Vector"
        this.elements = elements

class MapExpr:
    string tag
    vector[dynamic] keys
    vector[dynamic] values
    void fn __init__(vector[dynamic] keys, vector[dynamic] values):
        this.tag = "Map"
        this.keys = keys
        this.values = values

class GetExpr:
    string tag
    dynamic object
    dynamic name
    void fn __init__(dynamic object, dynamic name):
        this.tag = "Get"
        this.object = object
        this.name = name

class SetExpr:
    string tag
    dynamic object
    dynamic name
    dynamic value
    void fn __init__(dynamic object, dynamic name, dynamic value):
        this.tag = "Set"
        this.object = object
        this.name = name
        this.value = value

class StaticGetExpr:
    string tag
    dynamic object
    dynamic name
    void fn __init__(dynamic object, dynamic name):
        this.tag = "StaticGet"
        this.object = object
        this.name = name

class ThisExpr:
    string tag
    dynamic keyword
    void fn __init__(dynamic keyword):
        this.tag = "This"
        this.keyword = keyword

class CastExpr:
    string tag
    dynamic expr
    dynamic target_type
    void fn __init__(dynamic expr, dynamic target_type):
        this.tag = "Cast"
        this.expr = expr
        this.target_type = target_type

class ThrowExpr:
    string tag
    dynamic expr
    void fn __init__(dynamic expr):
        this.tag = "Throw"
        this.expr = expr

// ── Type node ─────────────────────────────────────────────────

class TypeNode:
    string tag
    string name
    dynamic inner
    dynamic key_type
    dynamic value_type
    void fn __init__(string tag, string name, dynamic inner, dynamic key_type, dynamic value_type):
        this.tag = tag
        this.name = name
        this.inner = inner
        this.key_type = key_type
        this.value_type = value_type

dynamic fn make_simple_type(string tag):
    return TypeNode(tag, "", null, null, null)

dynamic fn make_custom_type(string name):
    return TypeNode("Custom", name, null, null, null)

dynamic fn make_array_type(dynamic inner):
    return TypeNode("Array", "", inner, null, null)

dynamic fn make_dict_type(dynamic key_type, dynamic value_type):
    return TypeNode("Dict", "", null, key_type, value_type)

dynamic fn make_nullable_type(dynamic inner):
    return TypeNode("Nullable", "", inner, null, null)

// ── Statement AST nodes ───────────────────────────────────────

class ExprStmt:
    string tag
    dynamic expr
    void fn __init__(dynamic expr):
        this.tag = "ExprStmt"
        this.expr = expr

class LetStmt:
    string tag
    dynamic name
    dynamic var_type
    dynamic initializer
    string visibility
    void fn __init__(dynamic name, dynamic var_type, dynamic initializer, string visibility):
        this.tag = "Let"
        this.name = name
        this.var_type = var_type
        this.initializer = initializer
        this.visibility = visibility

class ConstStmt:
    string tag
    dynamic name
    dynamic const_type
    dynamic value
    string visibility
    void fn __init__(dynamic name, dynamic const_type, dynamic value, string visibility):
        this.tag = "Const"
        this.name = name
        this.const_type = const_type
        this.value = value
        this.visibility = visibility

class ReturnStmt:
    string tag
    dynamic keyword
    dynamic value
    void fn __init__(dynamic keyword, dynamic value):
        this.tag = "Return"
        this.keyword = keyword
        this.value = value

class IfStmt:
    string tag
    dynamic condition
    dynamic then_branch
    dynamic else_branch
    void fn __init__(dynamic condition, dynamic then_branch, dynamic else_branch):
        this.tag = "If"
        this.condition = condition
        this.then_branch = then_branch
        this.else_branch = else_branch

class WhileStmt:
    string tag
    dynamic condition
    dynamic body
    void fn __init__(dynamic condition, dynamic body):
        this.tag = "While"
        this.condition = condition
        this.body = body

class ForStmt:
    string tag
    dynamic item_name
    dynamic collection
    dynamic body
    void fn __init__(dynamic item_name, dynamic collection, dynamic body):
        this.tag = "For"
        this.item_name = item_name
        this.collection = collection
        this.body = body

class BlockStmt:
    string tag
    vector[dynamic] statements
    void fn __init__(vector[dynamic] statements):
        this.tag = "Block"
        this.statements = statements

class TryStmt:
    string tag
    dynamic try_body
    dynamic catch_token
    dynamic exception_name
    dynamic catch_body
    void fn __init__(dynamic try_body, dynamic catch_token, dynamic exception_name, dynamic catch_body):
        this.tag = "Try"
        this.try_body = try_body
        this.catch_token = catch_token
        this.exception_name = exception_name
        this.catch_body = catch_body

// ── Declaration AST nodes ─────────────────────────────────────

class Param:
    string tag
    dynamic name
    dynamic param_type
    void fn __init__(dynamic name, dynamic param_type):
        this.tag = "Param"
        this.name = name
        this.param_type = param_type

class FunctionStmt:
    string tag
    dynamic name
    vector[dynamic] params
    dynamic return_type
    vector[dynamic] body
    bool is_inline
    bool is_comptime
    bool is_static
    string visibility
    void fn __init__(dynamic name, vector[dynamic] params, dynamic return_type, vector[dynamic] body, bool is_inline, bool is_comptime, bool is_static, string visibility):
        this.tag = "Function"
        this.name = name
        this.params = params
        this.return_type = return_type
        this.body = body
        this.is_inline = is_inline
        this.is_comptime = is_comptime
        this.is_static = is_static
        this.visibility = visibility

class ClassStmt:
    string tag
    dynamic name
    vector[dynamic] body
    string visibility
    void fn __init__(dynamic name, vector[dynamic] body, string visibility):
        this.tag = "Class"
        this.name = name
        this.body = body
        this.visibility = visibility

class StructStmt:
    string tag
    dynamic name
    vector[dynamic] body
    string visibility
    void fn __init__(dynamic name, vector[dynamic] body, string visibility):
        this.tag = "Struct"
        this.name = name
        this.body = body
        this.visibility = visibility

class EnumVariantNode:
    string tag
    dynamic name
    vector[dynamic] types
    void fn __init__(dynamic name, vector[dynamic] types):
        this.tag = "EnumVariant"
        this.name = name
        this.types = types

class EnumStmt:
    string tag
    dynamic name
    vector[dynamic] variants
    string visibility
    void fn __init__(dynamic name, vector[dynamic] variants, string visibility):
        this.tag = "Enum"
        this.name = name
        this.variants = variants
        this.visibility = visibility

class NamespaceStmt:
    string tag
    dynamic name
    vector[dynamic] body
    string visibility
    void fn __init__(dynamic name, vector[dynamic] body, string visibility):
        this.tag = "Namespace"
        this.name = name
        this.body = body
        this.visibility = visibility

class ImportStmt:
    string tag
    vector[dynamic] path
    dynamic alias
    void fn __init__(vector[dynamic] path, dynamic alias):
        this.tag = "Import"
        this.path = path
        this.alias = alias

// ── Parser class ──────────────────────────────────────────────

class Parser:
    vector[Token] tokens
    int current
    bool in_class_body

    void fn __init__(vector[Token] tokens):
        this.tokens = tokens
        this.current = 0
        this.in_class_body = false

    // ── Helpers ─────────────────────────────────────────────

    bool fn is_at_end():
        return this.peek().token_type == TK_EOF

    Token fn peek():
        return this.tokens[this.current]

    Token fn peek_at(int offset):
        if this.current + offset >= this.tokens.len():
            return this.tokens[this.tokens.len() - 1]
        return this.tokens[this.current + offset]

    Token fn previous():
        return this.tokens[this.current - 1]

    Token fn advance():
        if this.is_at_end() == false:
            this.current = this.current + 1
        return this.previous()

    Token fn consume(string tk_type, string message):
        if this.check(tk_type):
            return this.advance()
        auto t = this.peek()
        throw message + " Got " + t.token_type + " at " + t.line + ":" + t.col

    bool fn check(string tk_type):
        if this.is_at_end():
            return false
        return this.peek().token_type == tk_type

    bool fn match_any(vector[string] types):
        for t in types:
            if this.check(t):
                this.advance()
                return true
        return false

    void fn skip_formatting():
        while this.match_any([TK_NEWLINE, TK_INDENT, TK_DEDENT]):
            int noop = 0

    bool fn is_type_at_pos(int pos):
        auto t = this.peek_at(pos).token_type
        if t == TK_INT_TYPE:
            return true
        if t == TK_FLOAT_TYPE:
            return true
        if t == TK_STRING_TYPE:
            return true
        if t == TK_BOOL:
            return true
        if t == TK_VOID:
            return true
        if t == TK_AUTO:
            return true
        if t == TK_DYNAMIC:
            return true
        if t == TK_VECTOR:
            return true
        if t == TK_HASHMAP:
            return true
        if t == TK_IDENTIFIER:
            return true
        return false

    bool fn check_function_start():
        int offset = 0
        if this.is_type_at_pos(offset) == false:
            return false
        auto tt = this.peek_at(offset).token_type
        offset = offset + 1
        if tt == TK_VECTOR:
            offset = offset + 3
        else if tt == TK_HASHMAP:
            offset = offset + 5
        if this.peek_at(offset).token_type == TK_QUESTION:
            offset = offset + 1
        bool still_modifiers = true
        while offset < this.tokens.len() and still_modifiers:
            auto mt = this.peek_at(offset).token_type
            if mt == TK_INLINE or mt == TK_COMPTIME:
                offset = offset + 1
            else:
                still_modifiers = false
        return this.peek_at(offset).token_type == TK_FN

    // ── Type parsing ────────────────────────────────────────

    dynamic fn parse_type():
        dynamic t = null
        if this.match_any([TK_INT_TYPE]):
            t = make_simple_type("Int")
        else if this.match_any([TK_FLOAT_TYPE]):
            t = make_simple_type("Float")
        else if this.match_any([TK_STRING_TYPE]):
            t = make_simple_type("String")
        else if this.match_any([TK_BOOL]):
            t = make_simple_type("Bool")
        else if this.match_any([TK_VOID]):
            t = make_simple_type("Void")
        else if this.match_any([TK_AUTO]):
            t = make_simple_type("Auto")
        else if this.match_any([TK_DYNAMIC]):
            t = make_simple_type("Dynamic")
        else if this.match_any([TK_NULL]):
            t = make_simple_type("Null")
        else if this.match_any([TK_VECTOR]):
            this.consume(TK_LEFT_BRACKET, "Expect '[' after 'vector'.")
            dynamic inner = this.parse_type()
            this.consume(TK_RIGHT_BRACKET, "Expect ']' after vector type.")
            t = make_array_type(inner)
        else if this.match_any([TK_HASHMAP]):
            this.consume(TK_LEFT_BRACKET, "Expect '[' after 'hashmap'.")
            dynamic k = this.parse_type()
            this.consume(TK_COMMA, "Expect ',' between key and value types.")
            dynamic v = this.parse_type()
            this.consume(TK_RIGHT_BRACKET, "Expect ']' after hashmap types.")
            t = make_dict_type(k, v)
        else if this.match_any([TK_IDENTIFIER]):
            t = make_custom_type(this.previous().lexeme)
        else:
            auto tok = this.peek()
            throw "Expect type. Got " + tok.token_type + " at " + tok.line + ":" + tok.col

        if this.match_any([TK_QUESTION]):
            t = make_nullable_type(t)
        return t

    // ── Expression parsing ──────────────────────────────────

    dynamic fn expression():
        return this.assignment()

    dynamic fn assignment():
        dynamic expr = this.logical_or()
        if this.match_any([TK_EQUAL]):
            dynamic value = this.assignment()
            if expr.tag == "Variable":
                return AssignExpr(expr.name, value)
            else if expr.tag == "Get":
                return SetExpr(expr.object, expr.name, value)
            else:
                throw "Invalid assignment target."
        return expr

    dynamic fn logical_or():
        dynamic expr = this.logical_and()
        while this.match_any([TK_OR]):
            auto op = this.previous()
            dynamic right = this.logical_and()
            expr = LogicalExpr(expr, op, right)
        return expr

    dynamic fn logical_and():
        dynamic expr = this.equality()
        while this.match_any([TK_AND]):
            auto op = this.previous()
            dynamic right = this.equality()
            expr = LogicalExpr(expr, op, right)
        return expr

    dynamic fn equality():
        dynamic expr = this.comparison()
        while this.match_any([TK_BANG_EQUAL, TK_EQUAL_EQUAL]):
            auto op = this.previous()
            dynamic right = this.comparison()
            expr = BinaryExpr(expr, op, right)
        return expr

    dynamic fn comparison():
        dynamic expr = this.term()
        while this.match_any([TK_GREATER, TK_GREATER_EQUAL, TK_LESS, TK_LESS_EQUAL]):
            auto op = this.previous()
            dynamic right = this.term()
            expr = BinaryExpr(expr, op, right)
        return expr

    dynamic fn term():
        dynamic expr = this.factor()
        while this.match_any([TK_MINUS, TK_PLUS]):
            auto op = this.previous()
            dynamic right = this.factor()
            expr = BinaryExpr(expr, op, right)
        return expr

    dynamic fn factor():
        dynamic expr = this.unary()
        while this.match_any([TK_SLASH, TK_STAR]):
            auto op = this.previous()
            dynamic right = this.unary()
            expr = BinaryExpr(expr, op, right)
        return expr

    dynamic fn unary():
        if this.match_any([TK_BANG, TK_MINUS]):
            auto op = this.previous()
            dynamic right = this.unary()
            return UnaryExpr(op, right)
        return this.call()

    dynamic fn call():
        dynamic expr = this.primary()
        bool more = true
        while more:
            if this.match_any([TK_LEFT_PAREN]):
                expr = this.finish_call(expr)
            else if this.match_any([TK_LEFT_BRACKET]):
                dynamic index = this.expression()
                auto bracket = this.consume(TK_RIGHT_BRACKET, "Expect ']' after index.")
                expr = IndexExpr(expr, bracket, index)
            else if this.match_any([TK_DOT]):
                auto name = this.consume(TK_IDENTIFIER, "Expect property name after '.'.")
                expr = GetExpr(expr, name)
            else if this.match_any([TK_DOUBLE_COLON]):
                auto name = this.consume(TK_IDENTIFIER, "Expect member name after '::'.")
                expr = StaticGetExpr(expr, name)
            else:
                more = false
        return expr

    dynamic fn finish_call(dynamic callee):
        if callee.tag == "Variable" and callee.name.lexeme == "cast":
            dynamic expr = this.expression()
            this.consume(TK_COMMA, "Expect ',' after value in cast().")
            dynamic target = this.parse_type()
            this.consume(TK_RIGHT_PAREN, "Expect ')' after type in cast().")
            return CastExpr(expr, target)

        vector[dynamic] args = []
        if this.check(TK_RIGHT_PAREN) == false:
            args.push(this.expression())
            while this.match_any([TK_COMMA]):
                args.push(this.expression())
        auto paren = this.consume(TK_RIGHT_PAREN, "Expect ')' after arguments.")
        return CallExpr(callee, paren, args)

    dynamic fn primary():
        if this.match_any([TK_FALSE]):
            return LiteralExpr("bool", "false")
        if this.match_any([TK_TRUE]):
            return LiteralExpr("bool", "true")
        if this.match_any([TK_NULL]):
            return LiteralExpr("null", "null")
        if this.match_any([TK_INT]):
            return LiteralExpr("int", this.previous().lexeme)
        if this.match_any([TK_FLOAT]):
            return LiteralExpr("float", this.previous().lexeme)
        if this.match_any([TK_STRING]):
            return LiteralExpr("string", this.previous().lexeme)
        if this.match_any([TK_IDENTIFIER]):
            return VariableExpr(this.previous())
        if this.match_any([TK_THIS]):
            return ThisExpr(this.previous())
        if this.match_any([TK_LEFT_PAREN]):
            dynamic expr = this.expression()
            this.consume(TK_RIGHT_PAREN, "Expect ')' after expression.")
            return GroupingExpr(expr)
        if this.match_any([TK_LEFT_BRACKET]):
            vector[dynamic] elements = []
            this.skip_formatting()
            if this.check(TK_RIGHT_BRACKET) == false:
                this.skip_formatting()
                elements.push(this.expression())
                this.skip_formatting()
                while this.match_any([TK_COMMA]):
                    this.skip_formatting()
                    elements.push(this.expression())
                    this.skip_formatting()
            this.skip_formatting()
            this.consume(TK_RIGHT_BRACKET, "Expect ']' after vector literal.")
            return VectorExpr(elements)
        if this.match_any([TK_LEFT_BRACE]):
            vector[dynamic] keys = []
            vector[dynamic] values = []
            this.skip_formatting()
            if this.check(TK_RIGHT_BRACE) == false:
                this.skip_formatting()
                dynamic key = this.expression()
                this.skip_formatting()
                this.consume(TK_COLON, "Expect ':' after map key.")
                this.skip_formatting()
                dynamic value = this.expression()
                this.skip_formatting()
                keys.push(key)
                values.push(value)
                while this.match_any([TK_COMMA]):
                    this.skip_formatting()
                    key = this.expression()
                    this.skip_formatting()
                    this.consume(TK_COLON, "Expect ':' after map key.")
                    this.skip_formatting()
                    value = this.expression()
                    this.skip_formatting()
                    keys.push(key)
                    values.push(value)
            this.skip_formatting()
            this.consume(TK_RIGHT_BRACE, "Expect '}' after map literal.")
            return MapExpr(keys, values)

        auto t = this.peek()
        throw "Expect expression. Got " + t.token_type + " at " + t.line + ":" + t.col

    // ── Statement parsing ───────────────────────────────────

    dynamic fn statement():
        if this.match_any([TK_IF]):
            return this.if_statement()
        if this.match_any([TK_WHILE]):
            return this.while_statement()
        if this.match_any([TK_FOR]):
            return this.for_statement()
        if this.match_any([TK_RETURN]):
            return this.return_statement()
        if this.match_any([TK_THROW]):
            return this.throw_statement()
        return this.expression_statement()

    dynamic fn throw_statement():
        dynamic expr = this.expression()
        this.match_any([TK_SEMICOLON, TK_NEWLINE])
        return ExprStmt(ThrowExpr(expr))

    dynamic fn if_statement():
        dynamic condition = this.expression()
        this.consume(TK_COLON, "Expect ':' after if condition.")
        auto then_branch = BlockStmt(this.block())

        dynamic else_branch = null
        if this.match_any([TK_ELSE]):
            if this.match_any([TK_COLON]):
                else_branch = BlockStmt(this.block())
            else if this.check(TK_IF):
                else_branch = this.declaration()
        return IfStmt(condition, then_branch, else_branch)

    dynamic fn while_statement():
        dynamic condition = this.expression()
        this.consume(TK_COLON, "Expect ':' after while condition.")
        auto body = BlockStmt(this.block())
        return WhileStmt(condition, body)

    dynamic fn for_statement():
        auto item_name = this.consume(TK_IDENTIFIER, "Expect variable name after 'for'.")
        this.consume(TK_IN, "Expect 'in' after variable name.")
        dynamic collection = this.expression()
        this.consume(TK_COLON, "Expect ':' after for loop header.")
        auto body = BlockStmt(this.block())
        return ForStmt(item_name, collection, body)

    dynamic fn return_statement():
        auto keyword = this.previous()
        dynamic value = null
        if this.check(TK_NEWLINE) == false and this.check(TK_DEDENT) == false and this.is_at_end() == false:
            value = this.expression()
        this.match_any([TK_NEWLINE])
        return ReturnStmt(keyword, value)

    vector[dynamic] fn block():
        this.match_any([TK_NEWLINE])
        this.consume(TK_INDENT, "Expect indentation to start a block.")

        vector[dynamic] statements = []
        while this.check(TK_DEDENT) == false and this.is_at_end() == false:
            if this.match_any([TK_NEWLINE]):
                int noop = 0
            else:
                statements.push(this.declaration())
        this.consume(TK_DEDENT, "Expect dedent to end a block.")
        return statements

    dynamic fn expression_statement():
        dynamic expr = this.expression()
        this.match_any([TK_SEMICOLON, TK_NEWLINE])
        return ExprStmt(expr)

    // ── Declaration parsing ─────────────────────────────────

    dynamic fn var_declaration(string visibility):
        dynamic var_type = this.parse_type()
        auto name = this.consume(TK_IDENTIFIER, "Expect variable name after type.")

        dynamic initializer = null
        if this.match_any([TK_EQUAL]):
            initializer = this.expression()
        this.match_any([TK_SEMICOLON, TK_NEWLINE])
        return LetStmt(name, var_type, initializer, visibility)

    dynamic fn const_declaration(string visibility):
        dynamic const_type = this.parse_type()
        auto name = this.consume(TK_IDENTIFIER, "Expect constant name after type.")
        this.consume(TK_EQUAL, "Const declaration must have an initializer.")
        dynamic value = this.expression()
        this.match_any([TK_SEMICOLON, TK_NEWLINE])
        return ConstStmt(name, const_type, value, visibility)

    dynamic fn function_declaration(string visibility, bool is_static):
        dynamic return_type = this.parse_type()

        bool is_inline = false
        bool is_comptime = false
        while this.match_any([TK_INLINE, TK_COMPTIME]):
            if this.previous().token_type == TK_INLINE:
                is_inline = true
            if this.previous().token_type == TK_COMPTIME:
                is_comptime = true

        this.consume(TK_FN, "Expect 'fn' keyword after return type.")
        auto name = this.consume(TK_IDENTIFIER, "Expect function name.")

        this.consume(TK_LEFT_PAREN, "Expect '(' after function name.")
        vector[dynamic] params = []
        if this.check(TK_RIGHT_PAREN) == false:
            dynamic param_type = this.parse_type()
            auto param_name = this.consume(TK_IDENTIFIER, "Expect parameter name.")
            params.push(Param(param_name, param_type))
            while this.match_any([TK_COMMA]):
                param_type = this.parse_type()
                param_name = this.consume(TK_IDENTIFIER, "Expect parameter name.")
                params.push(Param(param_name, param_type))
        this.consume(TK_RIGHT_PAREN, "Expect ')' after parameters.")

        this.consume(TK_COLON, "Expect ':' before function body.")
        vector[dynamic] body = this.block()
        return FunctionStmt(name, params, return_type, body, is_inline, is_comptime, is_static, visibility)

    dynamic fn class_declaration(string visibility):
        auto name = this.consume(TK_IDENTIFIER, "Expect class name.")
        this.consume(TK_COLON, "Expect ':' after class name.")
        auto old = this.in_class_body
        this.in_class_body = true
        auto body = this.block()
        this.in_class_body = old
        return ClassStmt(name, body, visibility)

    dynamic fn struct_declaration(string visibility):
        auto name = this.consume(TK_IDENTIFIER, "Expect struct name.")
        this.consume(TK_COLON, "Expect ':' after struct name.")
        auto old = this.in_class_body
        this.in_class_body = true
        auto body = this.block()
        this.in_class_body = old
        return StructStmt(name, body, visibility)

    dynamic fn enum_declaration(string visibility):
        auto name = this.consume(TK_IDENTIFIER, "Expect enum name.")
        this.consume(TK_COLON, "Expect ':' after enum name.")

        this.match_any([TK_NEWLINE])
        this.consume(TK_INDENT, "Expect indentation to start enum body.")

        vector[dynamic] variants = []
        while this.check(TK_DEDENT) == false and this.is_at_end() == false:
            if this.match_any([TK_NEWLINE]):
                int noop = 0
            else:
                dynamic vtype = this.parse_type()
                auto vname = this.consume(TK_IDENTIFIER, "Expect variant name.")
                vector[dynamic] types = []
                if vtype.tag != "Null" and vtype.tag != "Void":
                    types.push(vtype)
                variants.push(EnumVariantNode(vname, types))
                this.match_any([TK_NEWLINE])

        this.consume(TK_DEDENT, "Expect dedent to end enum body.")
        return EnumStmt(name, variants, visibility)

    dynamic fn import_statement():
        vector[dynamic] path = []
        path.push(this.consume(TK_IDENTIFIER, "Expect module name."))
        while this.match_any([TK_DOUBLE_COLON]):
            path.push(this.consume(TK_IDENTIFIER, "Expect module name."))

        dynamic alias = null
        if this.match_any([TK_AS]):
            alias = this.consume(TK_IDENTIFIER, "Expect alias name after 'as'.")
        this.match_any([TK_SEMICOLON, TK_NEWLINE])
        return ImportStmt(path, alias)

    dynamic fn namespace_statement(string visibility):
        auto name = this.consume(TK_IDENTIFIER, "Expect namespace name.")
        this.consume(TK_COLON, "Expect ':' after namespace name.")
        auto body = this.block()
        return NamespaceStmt(name, body, visibility)

    dynamic fn try_statement():
        this.consume(TK_COLON, "Expect ':' after 'try'.")
        auto try_body = BlockStmt(this.block())

        auto catch_token = this.consume(TK_CATCH, "Expect 'catch' after 'try' block.")
        dynamic exception_name = null
        if this.match_any([TK_IDENTIFIER]):
            exception_name = this.previous()
        this.consume(TK_COLON, "Expect ':' after 'catch'.")
        auto catch_body = BlockStmt(this.block())
        return TryStmt(try_body, catch_token, exception_name, catch_body)

    dynamic fn declaration():
        string visibility = "public"
        if this.match_any([TK_PRIVATE]):
            visibility = "private"
        else if this.match_any([TK_PUBLIC]):
            visibility = "public"

        bool is_static = this.match_any([TK_STATIC])

        while this.check(TK_HASH):
            while this.check(TK_NEWLINE) == false and this.is_at_end() == false:
                this.advance()
            this.match_any([TK_NEWLINE])

        if this.match_any([TK_IMPORT]):
            return this.import_statement()

        if this.match_any([TK_NAMESPACE]):
            return this.namespace_statement(visibility)

        if this.match_any([TK_CLASS]):
            return this.class_declaration(visibility)

        if this.match_any([TK_STRUCT]):
            return this.struct_declaration(visibility)

        if this.match_any([TK_ENUM]):
            return this.enum_declaration(visibility)

        if this.match_any([TK_TRY]):
            return this.try_statement()

        if this.match_any([TK_CONST]):
            return this.const_declaration(visibility)

        if this.is_type_at_pos(0):
            int next_pos = 1
            auto current_type = this.peek().token_type
            if current_type == TK_VECTOR:
                next_pos = 4
            else if current_type == TK_HASHMAP:
                next_pos = 6

            if this.peek_at(next_pos).token_type == TK_QUESTION:
                next_pos = next_pos + 1

            auto next_token = this.peek_at(next_pos).token_type
            if next_token == TK_IDENTIFIER or next_token == TK_FN or next_token == TK_INLINE or next_token == TK_COMPTIME:
                if this.check_function_start():
                    return this.function_declaration(visibility, is_static)
                if this.in_class_body == false:
                    int eq_pos = next_pos + 1
                    if this.peek_at(eq_pos).token_type != TK_EQUAL:
                        auto tok = this.peek_at(next_pos)
                        throw "Bare field declarations are only allowed inside class/struct at " + tok.line + ":" + tok.col
                return this.var_declaration(visibility)

        return this.statement()

    // ── Main entry point ────────────────────────────────────

    vector[dynamic] fn parse_program():
        vector[dynamic] statements = []
        while this.is_at_end() == false:
            if this.match_any([TK_NEWLINE]):
                int noop = 0
            else:
                statements.push(this.declaration())
        return statements


// ═══════════════════════════════════════════════════════════════
//  Test: parse a simple expression
// ═══════════════════════════════════════════════════════════════

void fn main():
    test_scanner()

    auto parser_test_source = "1 + 2 * 3\n"
    auto parser_test_scanner = Scanner(parser_test_source)
    parser_test_scanner.scan_tokens()

    auto parser = Parser(parser_test_scanner.tokens)
    vector[dynamic] stmts = parser.parse_program()

    print("Parsed statements: " + stmts.len())
    for stmt in stmts:
        dynamic expr = stmt.expr
        if stmt.tag == "ExprStmt":
            if expr.tag == "Binary":
                dynamic right = expr.right
                print("Binary: " + expr.op.lexeme)
                if right.tag == "Binary":
                    print("  Right is Binary: " + right.op.lexeme)
                    print("OK: precedence correct (1 + (2 * 3))")
