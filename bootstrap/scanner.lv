// ═══════════════════════════════════════════════════════════════
//  Lavina Bootstrap Compiler — Scanner / Lexer
//  Translates source code into a flat list of tokens.
// ═══════════════════════════════════════════════════════════════

// ── Token types as string constants ─────────────────────────────

const string TK_LEFT_PAREN = "LeftParen"
const string TK_RIGHT_PAREN = "RightParen"
const string TK_LEFT_BRACKET = "LeftBracket"
const string TK_RIGHT_BRACKET = "RightBracket"
const string TK_LEFT_BRACE = "LeftBrace"
const string TK_RIGHT_BRACE = "RightBrace"
const string TK_COMMA = "Comma"
const string TK_DOT = "Dot"
const string TK_DOT_DOT = "DotDot"
const string TK_MINUS = "Minus"
const string TK_PLUS = "Plus"
const string TK_SEMICOLON = "Semicolon"
const string TK_SLASH = "Slash"
const string TK_STAR = "Star"
const string TK_COLON = "Colon"
const string TK_HASH = "Hash"
const string TK_QUESTION = "Question"
const string TK_PERCENT = "Percent"
const string TK_BANG = "Bang"
const string TK_BANG_EQUAL = "BangEqual"
const string TK_EQUAL = "Equal"
const string TK_EQUAL_EQUAL = "EqualEqual"
const string TK_GREATER = "Greater"
const string TK_GREATER_EQUAL = "GreaterEqual"
const string TK_LESS = "Less"
const string TK_LESS_EQUAL = "LessEqual"
const string TK_ARROW = "Arrow"
const string TK_DOUBLE_COLON = "DoubleColon"
const string TK_IDENTIFIER = "Identifier"
const string TK_STRING = "String"
const string TK_INT = "Int"
const string TK_FLOAT = "Float"
const string TK_AND = "And"
const string TK_AUTO = "Auto"
const string TK_BOOL = "Bool"
const string TK_COMPTIME = "Comptime"
const string TK_DYNAMIC = "Dynamic"
const string TK_ELSE = "Else"
const string TK_ELIF = "Elif"
const string TK_FALSE = "False"
const string TK_FLOAT_TYPE = "FloatType"
const string TK_FN = "Fn"
const string TK_IF = "If"
const string TK_INLINE = "Inline"
const string TK_INT_TYPE = "IntType"
const string TK_NULL = "Null"
const string TK_OR = "Or"
const string TK_RETURN = "Return"
const string TK_STRING_TYPE = "StringType"
const string TK_TRUE = "True"
const string TK_VOID = "Void"
const string TK_WHILE = "While"
const string TK_FOR = "For"
const string TK_IN = "In"
const string TK_VECTOR = "Vector"
const string TK_HASHMAP = "HashMap"
const string TK_HASHSET = "HashSet"
const string TK_IMPORT = "Import"
const string TK_AS = "As"
const string TK_NAMESPACE = "Namespace"
const string TK_PUBLIC = "Public"
const string TK_PRIVATE = "Private"
const string TK_STATIC = "Static"
const string TK_CLASS = "Class"
const string TK_STRUCT = "Struct"
const string TK_ENUM = "Enum"
const string TK_THIS = "This"
const string TK_TRY = "Try"
const string TK_CATCH = "Catch"
const string TK_THROW = "Throw"
const string TK_CONST = "Const"
const string TK_LET = "Let"
const string TK_MATCH = "Match"
const string TK_BREAK = "Break"
const string TK_CONTINUE = "Continue"
const string TK_NOT = "Not"
const string TK_INDENT = "Indent"
const string TK_DEDENT = "Dedent"
const string TK_NEWLINE = "Newline"
const string TK_EOF = "Eof"

// ── Token struct ────────────────────────────────────────────────

class Token:
    constructor(string token_type, string lexeme, int line, int col):
        this.token_type = token_type
        this.lexeme = lexeme
        this.line = line
        this.col = col

    string fn to_string():
        return this.token_type + "(" + this.lexeme + ") at " + this.line + ":" + this.col

// ── Keyword lookup ──────────────────────────────────────────────

string fn lookup_keyword(auto w):
    if w == "and":
        return TK_AND
    elif w == "auto":
        return TK_AUTO
    elif w == "bool":
        return TK_BOOL
    elif w == "comptime":
        return TK_COMPTIME
    elif w == "dynamic":
        return TK_DYNAMIC
    elif w == "else":
        return TK_ELSE
    elif w == "elif":
        return TK_ELIF
    elif w == "false":
        return TK_FALSE
    elif w == "float":
        return TK_FLOAT_TYPE
    elif w == "fn":
        return TK_FN
    elif w == "if":
        return TK_IF
    elif w == "inline":
        return TK_INLINE
    elif w == "int":
        return TK_INT_TYPE
    elif w == "null":
        return TK_NULL
    elif w == "or":
        return TK_OR
    elif w == "return":
        return TK_RETURN
    elif w == "string":
        return TK_STRING_TYPE
    elif w == "true":
        return TK_TRUE
    elif w == "void":
        return TK_VOID
    elif w == "while":
        return TK_WHILE
    elif w == "for":
        return TK_FOR
    elif w == "in":
        return TK_IN
    elif w == "vector":
        return TK_VECTOR
    elif w == "hashmap":
        return TK_HASHMAP
    elif w == "hashset":
        return TK_HASHSET
    elif w == "import":
        return TK_IMPORT
    elif w == "as":
        return TK_AS
    elif w == "namespace":
        return TK_NAMESPACE
    elif w == "public":
        return TK_PUBLIC
    elif w == "private":
        return TK_PRIVATE
    elif w == "static":
        return TK_STATIC
    elif w == "class":
        return TK_CLASS
    elif w == "struct":
        return TK_STRUCT
    elif w == "enum":
        return TK_ENUM
    elif w == "this":
        return TK_THIS
    elif w == "try":
        return TK_TRY
    elif w == "catch":
        return TK_CATCH
    elif w == "throw":
        return TK_THROW
    elif w == "const":
        return TK_CONST
    elif w == "let":
        return TK_LET
    elif w == "match":
        return TK_MATCH
    elif w == "break":
        return TK_BREAK
    elif w == "continue":
        return TK_CONTINUE
    elif w == "not":
        return TK_NOT
    return ""

// ── Helper functions ────────────────────────────────────────────

bool fn is_alpha(auto c):
    if c >= "a" and c <= "z":
        return true
    elif c >= "A" and c <= "Z":
        return true
    elif c == "_":
        return true
    return false

bool fn is_digit(auto c):
    if c >= "0" and c <= "9":
        return true
    return false

bool fn is_alnum(auto c):
    if is_alpha(c):
        return true
    if is_digit(c):
        return true
    return false

// ── Scanner class ───────────────────────────────────────────────

class Scanner:
    string source
    vector[Token] tokens
    vector[string] errors
    int start
    int current
    int line
    int column
    int start_line
    int start_column
    vector[int] indent_stack
    bool at_line_start
    bool in_string_interp
    int interp_brace_depth

    constructor(string source):
        this.source = source
        this.tokens = []
        this.errors = []
        this.start = 0
        this.current = 0
        this.line = 1
        this.column = 1
        this.start_line = 1
        this.start_column = 1
        this.indent_stack = [0]
        this.at_line_start = true
        this.in_string_interp = false
        this.interp_brace_depth = 0

    bool fn is_at_end():
        return this.current >= this.source.len()

    auto fn peek():
        if this.is_at_end():
            return ""
        return this.source.charAt(this.current)

    auto fn peek_next():
        if this.current + 1 >= this.source.len():
            return ""
        return this.source.charAt(this.current + 1)

    auto fn advance():
        auto c = this.source.charAt(this.current)
        this.current = this.current + 1
        this.column = this.column + 1
        return c

    bool fn match_char(string expected):
        if this.is_at_end():
            return false
        if this.source.charAt(this.current) != expected:
            return false
        this.current = this.current + 1
        this.column = this.column + 1
        return true

    void fn add_token(string tk_type, string lexeme):
        int sl = this.start_line
        int sc = this.start_column
        auto tok = Token(tk_type, lexeme, sl, sc)
        this.tokens.push(tok)

    void fn add_simple_token(string tk_type):
        auto lexeme = this.source.substring(this.start, this.current)
        this.add_token(tk_type, lexeme)

    void fn add_error(string message):
        auto err = "Error at line " + this.line + ":" + this.column + ": " + message
        this.errors.push(err)

    // ── Indentation handling ────────────────────────────────────

    void fn handle_indentation():
        int indent = 0
        while not this.is_at_end() and (this.peek() == " " or this.peek() == "\t"):
            auto c = this.advance()
            if c == " ":
                indent = indent + 1
            else:
                indent = indent + 4

        if this.is_at_end() or this.peek() == "\n":
            if this.peek() == "\n":
                this.at_line_start = true
            return

        auto current_indent = this.indent_stack[this.indent_stack.len() - 1]
        if indent > current_indent:
            this.indent_stack.push(indent)
            this.add_token(TK_INDENT, "")
        elif indent < current_indent:
            while indent < this.indent_stack[this.indent_stack.len() - 1]:
                this.indent_stack.pop()
                this.add_token(TK_DEDENT, "")
        this.at_line_start = false

    // ── Scan individual tokens ──────────────────────────────────

    void fn scan_string():
        int str_start = this.current
        while not this.is_at_end() and this.peek() != "\"":
            if this.peek() == "\\":
                this.advance()
                this.advance()
            elif this.peek() == "$" and this.peek_next() == "{":
                auto value = this.source.substring(str_start, this.current)
                this.add_token(TK_STRING, value)
                this.add_token(TK_PLUS, "+")
                this.add_token(TK_LEFT_PAREN, "(")
                this.advance()
                this.advance()
                this.in_string_interp = true
                this.interp_brace_depth = 1
                return
            else:
                if this.peek() == "\n":
                    this.line = this.line + 1
                    this.column = 1
                this.advance()

        if this.is_at_end():
            this.add_error("Unterminated string")
            return

        auto value = this.source.substring(str_start, this.current)
        this.advance()
        this.add_token(TK_STRING, value)

    void fn scan_string_rest():
        int str_start = this.current
        while not this.is_at_end() and this.peek() != "\"":
            if this.peek() == "\\":
                this.advance()
                this.advance()
            elif this.peek() == "$" and this.peek_next() == "{":
                auto value = this.source.substring(str_start, this.current)
                this.add_token(TK_STRING, value)
                this.add_token(TK_PLUS, "+")
                this.add_token(TK_LEFT_PAREN, "(")
                this.advance()
                this.advance()
                this.in_string_interp = true
                this.interp_brace_depth = 1
                return
            else:
                if this.peek() == "\n":
                    this.line = this.line + 1
                    this.column = 1
                this.advance()

        if this.is_at_end():
            this.add_error("Unterminated string")
            return

        auto value = this.source.substring(str_start, this.current)
        this.advance()
        this.add_token(TK_STRING, value)

    void fn scan_number():
        while is_digit(this.peek()):
            this.advance()

        if this.peek() == "." and is_digit(this.peek_next()):
            this.advance()
            while is_digit(this.peek()):
                this.advance()
            this.add_simple_token(TK_FLOAT)
        else:
            this.add_simple_token(TK_INT)

    void fn scan_identifier():
        while is_alnum(this.peek()):
            this.advance()

        auto text = this.source.substring(this.start, this.current)
        auto kw = lookup_keyword(text)
        if kw != "":
            this.add_token(kw, text)
        else:
            this.add_token(TK_IDENTIFIER, text)

    void fn scan_token():
        if this.at_line_start:
            this.handle_indentation()
            this.start = this.current
            this.start_line = this.line
            this.start_column = this.column

        if this.is_at_end():
            return

        auto c = this.advance()

        if c == "(":
            this.add_simple_token(TK_LEFT_PAREN)
        elif c == ")":
            this.add_simple_token(TK_RIGHT_PAREN)
        elif c == "[":
            this.add_simple_token(TK_LEFT_BRACKET)
        elif c == "]":
            this.add_simple_token(TK_RIGHT_BRACKET)
        elif c == "{":
            if this.in_string_interp:
                this.interp_brace_depth = this.interp_brace_depth + 1
            this.add_simple_token(TK_LEFT_BRACE)
        elif c == "}":
            if this.in_string_interp:
                this.interp_brace_depth = this.interp_brace_depth - 1
                if this.interp_brace_depth == 0:
                    this.in_string_interp = false
                    this.add_token(TK_RIGHT_PAREN, ")")
                    this.add_token(TK_PLUS, "+")
                    this.scan_string_rest()
                    return
            this.add_simple_token(TK_RIGHT_BRACE)
        elif c == ",":
            this.add_simple_token(TK_COMMA)
        elif c == ".":
            if this.match_char("."):
                this.add_simple_token(TK_DOT_DOT)
            else:
                this.add_simple_token(TK_DOT)
        elif c == "?":
            this.add_simple_token(TK_QUESTION)
        elif c == "+":
            this.add_simple_token(TK_PLUS)
        elif c == ";":
            this.add_simple_token(TK_SEMICOLON)
        elif c == "*":
            this.add_simple_token(TK_STAR)
        elif c == "%":
            this.add_simple_token(TK_PERCENT)
        elif c == "-":
            if this.match_char(">"):
                this.add_simple_token(TK_ARROW)
            else:
                this.add_simple_token(TK_MINUS)
        elif c == ":":
            if this.match_char(":"):
                this.add_simple_token(TK_DOUBLE_COLON)
            else:
                this.add_simple_token(TK_COLON)
        elif c == "#":
            this.add_simple_token(TK_HASH)
        elif c == "!":
            if this.match_char("="):
                this.add_simple_token(TK_BANG_EQUAL)
            else:
                this.add_simple_token(TK_BANG)
        elif c == "=":
            if this.match_char("="):
                this.add_simple_token(TK_EQUAL_EQUAL)
            else:
                this.add_simple_token(TK_EQUAL)
        elif c == "<":
            if this.match_char("="):
                this.add_simple_token(TK_LESS_EQUAL)
            else:
                this.add_simple_token(TK_LESS)
        elif c == ">":
            if this.match_char("="):
                this.add_simple_token(TK_GREATER_EQUAL)
            else:
                this.add_simple_token(TK_GREATER)
        elif c == "/":
            if this.match_char("/"):
                while this.peek() != "\n" and not this.is_at_end():
                    this.advance()
            else:
                this.add_simple_token(TK_SLASH)
        elif c == " " or c == "\r" or c == "\t":
            int noop = 0
        elif c == "\n":
            this.add_token(TK_NEWLINE, "\n")
            this.line = this.line + 1
            this.column = 1
            this.at_line_start = true
        elif c == "\"":
            this.scan_string()
        elif is_digit(c):
            this.scan_number()
        elif is_alpha(c):
            this.scan_identifier()
        else:
            this.add_error("Unexpected character: " + c)

    // ── Main entry point ────────────────────────────────────────

    void fn scan_tokens():
        while not this.is_at_end():
            this.start = this.current
            this.start_line = this.line
            this.start_column = this.column
            this.scan_token()

        // Emit remaining dedents
        while this.indent_stack.len() > 1:
            this.indent_stack.pop()
            this.add_token(TK_DEDENT, "")

        this.add_token(TK_EOF, "")


// ═══════════════════════════════════════════════════════════════
//  Test: scan a simple Lavina program (used when run standalone)
// ═══════════════════════════════════════════════════════════════

void fn test_scanner():
    auto test_source = "int fn add(int a, int b):\n    return a + b\n\nprint(add(2, 3))\n"

    auto scanner = Scanner(test_source)
    scanner.scan_tokens()

    print("Tokens: " + scanner.tokens.len())
    if scanner.errors.len() > 0:
        print("ERRORS:")
        for err in scanner.errors:
            print(err)
    else:
        for tok in scanner.tokens:
            print(tok.to_string())
