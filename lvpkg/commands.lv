// commands.lv — lvpkg command implementations

string DEPS_DIR = "deps"
string DEPS_SRC = "deps/src"
string DEPS_INCLUDE = "deps/include"
string DEPS_LIB = "deps/lib"

// Copy relevant files from a cloned dep into deps/include/
void fn link_dep(ref Dep dep):
    string src_dir = "${DEPS_SRC}/${dep.name}"

    if dep.path != "":
        string src_path = "${src_dir}/${dep.path}"
        if ends_with(dep.path, "/"):
            // path is a directory — copy into include/<name>/
            string dst = "${DEPS_INCLUDE}/${dep.name}"
            copy_dir_recursive(src_path, dst)
            info("${dep.name}: copied ${dep.path} → include/${dep.name}/")
        else:
            // path is a single file — copy into include/
            string filename = basename(dep.path)
            copy_file(src_path, "${DEPS_INCLUDE}/${filename}")
            info("${dep.name}: copied ${filename} → include/")
    else:
        // no path — copy entire repo into include/<name>/
        string dst = "${DEPS_INCLUDE}/${dep.name}"
        copy_dir_recursive(src_dir, dst)
        info("${dep.name}: copied repo → include/${dep.name}/")

// Copy library files and headers from a cloned lib dep
void fn link_lib_dep(ref Dep dep):
    string src_dir = "${DEPS_SRC}/${dep.name}"

    // Copy library file to deps/lib/
    string lib_src = "${src_dir}/${dep.lib_path}"
    if ends_with(dep.lib_path, "/"):
        // directory of libs — copy all into deps/lib/
        copy_dir_recursive(lib_src, DEPS_LIB)
        info("${dep.name}: copied ${dep.lib_path} → lib/")
    else:
        // single lib file
        string lib_filename = basename(dep.lib_path)
        copy_file(lib_src, "${DEPS_LIB}/${lib_filename}")
        info("${dep.name}: copied ${lib_filename} → lib/")

    // Copy headers if specified
    if dep.path != "":
        string hdr_src = "${src_dir}/${dep.path}"
        if ends_with(dep.path, "/"):
            string dst = "${DEPS_INCLUDE}/${dep.name}"
            copy_dir_recursive(hdr_src, dst)
            info("${dep.name}: copied ${dep.path} → include/${dep.name}/")
        else:
            string hdr_filename = basename(dep.path)
            copy_file(hdr_src, "${DEPS_INCLUDE}/${hdr_filename}")
            info("${dep.name}: copied ${hdr_filename} → include/")

// Install all dependencies: clone if missing, then link
void fn cmd_install():
    auto deps = parse_pkg_file()
    if deps.len() == 0:
        warn("No dependencies found in ${PKG_FILE}")
        return

    print("${C_BOLD}Installing ${__int_to_str(deps.len())} dependencies...${C_RESET}")
    print("")

    ensure_dir(DEPS_DIR)
    ensure_dir(DEPS_SRC)
    ensure_dir(DEPS_INCLUDE)

    bool has_libs = false
    for ref dep in deps:
        if dep.dep_type == "lib":
            has_libs = true
    if has_libs:
        ensure_dir(DEPS_LIB)

    for ref dep in deps:
        string dest = "${DEPS_SRC}/${dep.name}"
        if __fs_is_dir(dest):
            info("${dep.name}: already cloned, skipping (use 'update' to refresh)")
        else:
            git_clone(dep.url, dest, dep.version)
        if dep.dep_type == "lib":
            link_lib_dep(dep)
        else:
            link_dep(dep)

    print("")
    print("${C_GREEN}${C_BOLD}Done!${C_RESET}")

// Update all dependencies: fetch and checkout, then re-link
void fn cmd_update():
    auto deps = parse_pkg_file()
    if deps.len() == 0:
        warn("No dependencies found in ${PKG_FILE}")
        return

    print("${C_BOLD}Updating ${__int_to_str(deps.len())} dependencies...${C_RESET}")
    print("")

    ensure_dir(DEPS_DIR)
    ensure_dir(DEPS_SRC)
    ensure_dir(DEPS_INCLUDE)

    bool has_libs = false
    for ref dep in deps:
        if dep.dep_type == "lib":
            has_libs = true
    if has_libs:
        ensure_dir(DEPS_LIB)

    for ref dep in deps:
        string dest = "${DEPS_SRC}/${dep.name}"
        if __fs_is_dir(dest):
            git_update(dest, dep.version)
        else:
            git_clone(dep.url, dest, dep.version)
        if dep.dep_type == "lib":
            link_lib_dep(dep)
        else:
            link_dep(dep)

    print("")
    print("${C_GREEN}${C_BOLD}Done!${C_RESET}")

// List all dependencies and their install status
void fn cmd_list():
    auto deps = parse_pkg_file()
    if deps.len() == 0:
        print("No dependencies found.")
        return

    print("${C_BOLD}Dependencies (${__int_to_str(deps.len())}):${C_RESET}")
    print("")
    for ref dep in deps:
        string status = "${C_DIM}[not installed]${C_RESET}"
        if __fs_is_dir("${DEPS_SRC}/${dep.name}"):
            status = "${C_GREEN}[installed]${C_RESET}"

        string path_info = ""
        if dep.path != "":
            path_info = " ${C_DIM}→ ${dep.path}${C_RESET}"
        if dep.lib_path != "":
            path_info += " ${C_DIM}lib: ${dep.lib_path}${C_RESET}"

        print("  ${C_CYAN}${dep.name}${C_RESET} ${dep.url} @ ${C_YELLOW}${dep.version}${C_RESET}${path_info} ${status}")

// Remove the deps/ directory entirely
void fn cmd_clean():
    if __fs_is_dir(DEPS_DIR):
        step("Removing ${DEPS_DIR}/...")
        __os_exec("rm -rf ${DEPS_DIR}")
        info("Cleaned.")
    else:
        warn("Nothing to clean — ${DEPS_DIR}/ does not exist.")
